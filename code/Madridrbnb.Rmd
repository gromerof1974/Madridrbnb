

---
title: 'Tipología y ciclo de vida de los datos - Madrid Airbnb Data'
author: "Autores: Beatriz Lozano Ballesteros / Gabriel Romero Fernandez"
date: "Diciembre 2021"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 4
    includes:
      in_header: UOC_header.html
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=T, echo=T)
```


```{r echo=TRUE}
# Carga de librerías
if (!require('summarytools')){
  install.packages('summarytools', repos='http://cran.us.r-project.org')
  library('summarytools')
} 
if(!require(tidyverse)){
  install.packages('tidyverse', repos='http://cran.us.r-project.org')
  library(tidyverse)
}
if(!require(caret)){
  install.packages('caret', repos='http://cran.us.r-project.org')
  library(caret)
}
if(!require(corrplot)){
  install.packages('corrplot', repos='http://cran.us.r-project.org')
  library(corrplot)
}
if(!require(wordcloud)){
  install.packages('wordcloud', repos='http://cran.us.r-project.org')
  library(wordcloud)
}
if(!require(Rcpp)){
  install.packages('Rcpp', repos='http://cran.us.r-project.org')
  library(Rcpp)
}
if(!require(xlsx)){
  install.packages('xlsx', repos='http://cran.us.r-project.org')
  library(xlsx)
}
if(!require(plyr)){
  install.packages('plyr', repos='http://cran.us.r-project.org')
  library(plyr)
}
if(!require(BSDA)){
  install.packages('BSDA', repos='http://cran.us.r-project.org')
  library(BSDA)
}
if(!require(leaflet)){
  install.packages('leaflet', repos='http://cran.us.r-project.org')
  library(leaflet)
}
```


******
# Descripción del dataset
******

Madrid se ha convertido en uno de los destinos predilectos de la inversión inmobiliaria mexicana. El idioma, los lazos culturales entre ambos países, la oferta gastronómica, así como la seguridad jurídica y ciudadana, entre otros atractivos, han provocado el interés del capital inversor mexicano en la capital de España.

Una conocida firma de inversión inmobiliaria mexicana ha pedido realizar un estudio sobre la situación del mercado inmobiliario en la ciudad de Madrid. El problema a resolver es sencillo: ¿Dónde invertir? 

El inversor quiere respuesta a estas preguntas:

  - ¿Qué tipo de vivienda comprar?
  - ¿En qué zona de la capital?
  - ¿Qué destino se le va a dar al inmueble? Entre las opciones de alquiler turístico y tradicional.
  
Es un hecho conocido que el mercado de alquiler se encuentra en franco retroceso debido al auge de los alquileres turísticos. Los propietarios han cambiado el alquiler tradicional por el turístico, espoleado por compañías de impacto mundial como **AirBnB**. El efecto sobre el alquiler tradicional ha sido nefasto. Por un lado, la oferta de alquileres se ha reducido, lo que ha tenido un gran impacto en los precios, y por otro lado ha generado un flujo de habitantes hacia las zonas periféricas de la capital. El centro de la ciudad es de los turistas.

Debido a esto, y para dar respuesta a nuestro inversor mexicano, se utilizan datos de [AirBnB en Madrid](https://www.kaggle.com/rusiano/madrid-airbnb-data).

De todos los datos disponibles en este repositorio se utilizan los siguientes datasets:

- [listings.csv](https://www.kaggle.com/rusiano/madrid-airbnb-data?select=listings.csv): contiene información sobre los anuncios de alojamientos turísticos de Airbnb en Madrid (Ver [diccionario de datos](https://docs.google.com/spreadsheets/d/1iWCNJcSutYqpULSQHlNyGInUvHg2BoUGoNRIGa6Szc4/edit#gid=982310896))

- [reviews_detailed.csv](https://www.kaggle.com/rusiano/madrid-airbnb-data?select=reviews_detailed.csv): detalle de las reseñas por anuncio.

También se utilizarán estos datasets:

- [adjectives.csv](http://www.ashley-bovan.co.uk/words/partsofspeech.html): lista de adjetivos.

- [C5000121.xls](https://www.madrid.es/UnidadesDescentralizadas/UDCEstadistica/Nuevaweb/Demograf%C3%ADa%20y%20población/Indicadores%20Demográficos/C5000121.xls): datos de población por distrito.

El mejor enfoque para poder proporcionar una respuesta adecuada a un problema complejo, es dividir el problema en partes más pequeñas, más sencillas de responder, es por ello que se definen una serie de preguntas más específicas. Estas preguntas se hacen desde dos ángulos distintos: por un lado queremos analizar el aspecto geográfico, ¿dónde invertir?, y por otro lado lo concerniente al tipo de alojamiento a comprar ¿Qué comprar y para qué?.

Un poco de geografía: La ciudad de Madrid se divide en 21 distritos. La presencia de la carretera de circunvalación M-30 actúa como barrera geográfica entre los distritos de la almendra central (interior) de los del extrarradio. Dentro de la almendra central se encuentran los siguientes distritos (entre corchetes el precio de alquiler tradicional según el portal [Idealista](https://www.idealista.com/sala-de-prensa/informes-precio-vivienda/alquiler/madrid-comunidad/madrid-provincia/madrid/): **Centro** [17,5 euros/m2], **Tetuán** [15,0 euros/m2], **Chamartín** [15,4 euros/m2], **Chamberí** [17,1 euros/m2], **Salamanca** [17,5 euros/m2], **Retiro** [15,0 euros/m2] y **Arganzuela** [14,6 euros/m2]. 

En el extrarradio tenemos los siguientes distritos: **Barajas** [11,4 euros/m2], **Carabanchel** [11,7 euros/m2], **Ciudad Lineal** [12,8 euros/m2], **Fuencarral** [15,4 euros/m2],**Hortaleza** [12,5 euros/m2], **Latina** [11,8 euros/m2], **Moncloa** [14,3 euros/m2], **Moratalaz** [10,9 euros/m2], **Puente de Vallecas** [12,1 euros/m2], **San Blas** [11,4 euros/m2], **Usera** [11,5 euros/m2], **Vicálvaro** [10,4 euros/m2], **Villa de Vallecas** [11,2 euros/m2], **Villaverde** [10,9 euros/m2].

Estas son las preguntas relativas a la geografía de Madrid: 

- ¿Qué distritos tienen más alojamientos?

- ¿Qué tipo de alojamiento es el más frecuente por distrito?

- ¿Qué distrito es el más caro? ¿Qué distrito es el más barato? ¿Existen diferencias significativas de precio para los diferentes distritos?

- ¿Cúal es la densidad de alojamientos por distrito? ¿Qué distritos tienen una mayor densidad de alojamientos por habitante?

- ¿Existe una diferencia significativa entre los tipos de alojamiento por distrito?

Airbnb oferta 4 tipos de alojamientos: alojamiento completo, habitación privada, habitación compartida y habitación de hotel.Las preguntas a responder en este grupo son:

- ¿Qué tipo de alojamiento es el más frecuente?

- ¿Cuál es el precio medio de cada tipo de alojamiento?

- ¿Existe relación entre el precio y el número de casas/apartamentos de un mismo anfitrión?

- ¿Cuáles son las palabras más utilizadas en los títulos de los anuncios de alojamientos?

- ¿Cuantos alojamientos por tipo de habitación y precio hay? ¿Existen diferencias significativas de precio para los diferentes tipos de habitación?

- ¿Existe una diferencia significativa entre el promedio de reseñas por mes para los alojamientos de tipo habitación privada y apartamento?

- ¿Cómo es la estacionalidad en el alquiler de alojamientos turísticos?

- ¿Se podría construir un modelo para predecir el precio del alojamiento en función de otras variables?

Para responder a todas estas preguntas se usan técnicas de ciencia de datos. Todo comienza con la carga de los mismos.

## Carga de los datasets

### listings.csv

```{r}
# Limpiamos el workspace
rm(list = ls())

# Cargamos datasets 
df_listings <- read.csv('listings.csv', encoding = "UTF-8")

df_adjectives <- read.csv("adjectives.csv")
colnames(df_adjectives)[1]<-'word'

df_reviews <- read.csv('reviews_detailed.csv', header = TRUE)

df_population <- read.xlsx('C5000121.xls',sheetIndex=1, startRow=11, endRow=31, as.data.frame=TRUE, header=FALSE, colIndex=c(2,3))
colnames(df_population) <- c('neighbourhood_group', 'population')
```

Se carga el dataset y se visualiza su estructura.

```{r}
print(dfSummary(df_listings), method = 'render')
```

El Data Frame Summary muestra la siguiente información:

- **Dimensiones**: 19618 registros x 16 variables.
- **Duplicados**: 0.
- **Valores nulos (columna Missing)**: para la variable 14, reviews_per_month [numeric], hay 5637 valores perdidos, que representan el 28.7%.

También se muestra las estadísticas de cada variable, las frecuencias de los valores de las variables, gráficos con la distribución de frecuencias, y número y porcentaje de valores válidos de cada variable. Salvo para la variable **reviews_per_month**, los valores válidos son el 100% para el resto de las variables. 

Tenemos 6 variables discretas de tipo character:

- **name**: descripción del alojamiento.

- **host_name**: nombre del anfitrión (por lo general, sólo el nombre).

- **neighbourhood_group**: distrito. Toma 21 valores diferentes. Se observa que el 44.1% de los alojamientos están en el distrito Centro.

- **neighbourhood**: barrio. Toma 128 valores diferentes.

- **room_type**: tipo de alojamiento Toma 4 valores diferentes. Se observa que el 57.7% es para apartamento completo (Entire home/apt) y el 39.8% para habitación privada (Private room).

- **last_review**: fecha de la ultima reseña. La cadena vacía representa que no hay reseña.

Tenemos 10 variables numéricas:

- **id**: identificador del anuncio.

- **host_id**: identificador del anfitrión.

- **latitude**: latitud según el Sistema Geodésico Mundial (WGS84).

- **longitude**: longitud según el Sistema Geodésico Mundial (WGS84).

- **price**: precio diario en moneda local.

Se observa que el precio mínimo es 0, y el máximo 9999, lo que podría estar indicando que la ausencia de valores se ha codificado como 0 ó 9999, dependiendo del caso. Estos valores aparecerán como outliers (valores extremos).

- **minimum_nights**: cantidad mínima de noches de estancia para el alojamiento (las reglas del calendario pueden ser diferentes). El valor máximo toma un valor excesivamente alto (1125), lo que podría estar indicando una captura errónea del dato. Estos valores aparecerán como outliers.

- **number_of_reviews**: número de reseñas del anuncio.

- **reviews_per_month**: número de reseñas que tiene el anuncio durante su vida útil

- **calculated_host_listings_count**: Número de casas / apartamentos completos que tiene el anfitrión en el scrape actual, en la geografía de la ciudad / región. Observamos que el anfitrión con más alojamientos tiene 163.

- **availability_365**: Disponibilidad 365 días según determine el calendario. Hay que tener en cuenta que un anuncio puede no estar disponible porque ha sido reservado por un invitado o bloqueado por el anfitrión.

Es el principal dataset que se va a emplear en este análisis.

### adjectives.csv

```{r}
print(dfSummary(df_adjectives), method = 'render')
```

El Data Frame Summary contiene la siguiente información:

- **Dimensiones**: 28478 registros x 1 variable.
- **Duplicados**: 0.
- **Valores nulos (columna Missing)**: 0.

Hay 1 variable discreta de tipo character:

- **word**: adjetivos en lengua inglesa.

Este dataset se utilizará para limpiar palabras dentro del título del anuncio del alojamiento turístico.

### reviews_detailed.csv

```{r}
print(dfSummary(df_reviews), method = 'render')
```

- **Dimensiones**: 625006 registros x 6 variables.
- **Duplicados**: 0.
- **Valores nulos (columna Missing)**: para la variable 6, comments [character], hay 4 valores perdidos.

Hay 3 variables discretas de tipo character:

- **date**: fecha de la reseña.

- **reviewer_name**: nombre del cliente que deja la reseña.

- **comments **: comentarios del cliente.

Y 3 variables numéricas:

- **listing_id **: identificador del anuncio.

- **id**: identificador de la reseña.

- **reviewer_id**: identificador del cliente que deja la reseña.

Este dataset se utilizará para analizar la evolución temporal del alquiler turístico.

### C5000121.xls

```{r}
print(dfSummary(df_population), method = 'render')
```

- **Dimensiones**: 21 registros x 2 variables.
- **Duplicados**: 0.
- **Valores nulos (columna Missing)**: no hay valores perdidos.

Hay 1 variable discreta de tipo character:

- **neighbourhood_group **: distrito.

Y 1 variable numérica:

- **population**: número de habitantes.

Este dataset se empleará para calcular la densidad de población por alojamiento turístico.

******
# Limpieza de los datos
******

Una vez cargados los datos y analizado el contenido de cada dataset, se procede a su limpieza y normalización.

## Dataframe df_listings: Detección y gestión de datos que contienen ceros o elementos vacíos

```{r}
# Guardamos número de filas antes de la limpieza
num_rows <- nrow(df_listings)
# Guardamos contador de filas eliminadas
num_deleted_rows <- 0
```

Se comprueba la existencia de elementos vacíos.

```{r}
# ‘Not Available’ / Missing Values
colSums(is.na(df_listings))
```

Se observa que **reviews_per_month** es la única variable a la que le faltan valores. 
Que no haya reseñas no parece ser un error y se puede considerar un valor legítimo, por lo que se sustituyen los valores no disponibles por 0.

```{r}
df_listings$reviews_per_month[which(is.na(df_listings$reviews_per_month))] <- 0
# Comprobamos que tras la sustitución ya no hay elementos vacíos
colSums(is.na(df_listings))
```

Se comprueba si existen elementos con valores en blanco.

```{r}
colSums(df_listings=="")
```

Existen elementos con valores en blanco (**name**, **host_name** y **last_review**), pero no los vamos a tratar porque estas variables no se van a utilizar en el análisis posterior, a excepción de **name**, pero el hecho de que tenga tres valores en blanco no afecta al estudio.

Se comprueba si existen elementos con valores iguales a cero.

```{r}
colSums(df_listings==0)
```

Las variables **number_of_reviews**, **reviews_per_month**, **availability_365** y **price** tienen valores a cero. 

Para **number_of_reviews**, 0 se puede considerar un valor legítimo (no hay reseñas).

**reviews_per_month** la tratamos anteriormente y se determinó que 0 se podía considerar un valor legítimo. Si no hay reseñas, el acumulado está también a cero.

En el caso de **availability_365**, tal y como indicaba el [diccionario de datos](https://docs.google.com/spreadsheets/d/1iWCNJcSutYqpULSQHlNyGInUvHg2BoUGoNRIGa6Szc4/edit#gid=982310896), hay que tener en cuenta que un anuncio puede no estar disponible porque ha sido reservado por un invitado o bloqueado por el anfitrión, por lo que cero se puede considerar un valor legítimo.

Sin embargo, para **price**, el valor cero no parece tener sentido, ya que se estaría hablando de alojamiento gratuito. En este caso, no se tendrán en cuenta los registros con **price=0**.

```{r}
num_deleted_rows <- num_deleted_rows + nrow(df_listings[df_listings$price == 0,])
dim(df_listings)
df_listings <- df_listings[!(df_listings$price == 0),]
# Comprobamos que se han eliminado registros
dim(df_listings)
```

## Dataframe df_listings: Identificación y tratamiento de valores extremos

En la descripción del dataset, se observan dos variables con valores que llamaban la atención por tomar valores muy altos: **price** y **minimum_nights**.

**price**: el precio máximo es 9999, lo que podría estar indicando que la ausencia de valores se ha podido codificar como 9999 o que se trata de un error en el scrape. Estos valores aparecerán como outliers.

```{r}
ggplot() + 
  geom_boxplot(aes(y = df_listings$price), fill='#4271AE', outlier.colour='red', alpha=0.9) + 
  scale_x_discrete( ) + 
  labs(title = "Precio diario en euros", y = "Precio") +
  coord_flip()
```

Se eliminan los outliers por distrito. Para ello se determina un límite de precio máximo en el percentil 95 de los precios de cada distrito, y se eliminan todos los registros por encima de ese valor.

```{r}
# Se define una función para hacer la limpieza
clean_data <- function(dataframe, district_name){
  district <- df_listings[df_listings$neighbourhood_group==district_name,]
  district.quantile <- quantile(district$price, probs=c(.95), na.rm=T)
  df_listings <- df_listings[df_listings$neighbourhood_group!=district_name | (df_listings$neighbourhood_group==district_name & df_listings$price<district.quantile),]
  return(df_listings)
}

# Se limpian todos los distritos
df_listings = clean_data(df_listings, "Centro")
df_listings = clean_data(df_listings, "Arganzuela") 
df_listings = clean_data(df_listings, "Retiro") 
df_listings = clean_data(df_listings, "Salamanca") 
df_listings = clean_data(df_listings, "Chamartín") 
df_listings = clean_data(df_listings, "Tetuán") 
df_listings = clean_data(df_listings, "Chamberí") 
df_listings = clean_data(df_listings, "Fuencarral - El Pardo") 
df_listings = clean_data(df_listings, "Moncloa - Aravaca") 
df_listings = clean_data(df_listings, "Latina") 
df_listings = clean_data(df_listings, "Carabanchel") 
df_listings = clean_data(df_listings, "Usera") 
df_listings = clean_data(df_listings, "Puente de Vallecas") 
df_listings = clean_data(df_listings, "Moratalaz") 
df_listings = clean_data(df_listings, "Ciudad Lineal") 
df_listings = clean_data(df_listings, "Hortaleza") 
df_listings = clean_data(df_listings, "Villa de Vallecas") 
df_listings = clean_data(df_listings, "Vicálvaro") 
df_listings = clean_data(df_listings, "San Blas - Canillejas") 
df_listings = clean_data(df_listings, "Barajas")
df_listings = clean_data(df_listings, "Villaverde")

#num_deleted_rows <- num_deleted_rows + (nrow(df_listings) - nrow(df_cleaned))
#df_listings <- df_cleaned
```

Tras la limpieza se obtiene el siguiente boxplot:

```{r}
ggplot() + 
  geom_boxplot(aes(y = df_listings$price), fill='#4271AE', outlier.colour='red', alpha=0.9) + 
  scale_x_discrete( ) + 
  labs(title ="Precio diario en euros", y = "Precio") +
  coord_flip()
```

Se observa ahora que hay varios outliers que se considerarán válidos. Se entiende razonable que algunos alojamientos tengan un precio hasta 1500 euros por noche, es la parte del lujo en airbnb.

**minimum_nights**: el valor máximo toma un valor excesivamente alto (1125), lo que podría estar indicando una captura errónea del dato. Estos valores aparecerán como outliers.

```{r}
ggplot() + 
  geom_boxplot(aes(y = df_listings$minimum_nights), fill='#4271AE', outlier.colour='red', alpha=0.9) + 
  scale_x_discrete( ) + 
  labs(title = "Número mínimo de noches", y = "Número de noches") + 
  coord_flip()

```

Se decide no eliminar registros en este caso de valores, sino limitar estos registros a un mínimo de 365 noches al año.

```{r}
df_listings$minimum_nights[df_listings$minimum_nights>365]<-365
```

Tras la limpieza se obtiene el siguiente boxplot:

```{r}
ggplot() + 
  geom_boxplot(aes(y = df_listings$minimum_nights), fill='#4271AE', outlier.colour='red', alpha=0.9) + 
  scale_x_discrete( ) + 
  labs(title = "Número mínimo de noches", y = "Número de noches") + 
  coord_flip()
```

Los outliers se consideran válidos al haber propietarios que requieran mayor estabilidad en el alquiler.

Tras el proceso de limpieza, tenemos el siguiente balance:

```{r}
print(sprintf("El número total de filas eliminadas es %d, lo que representa el %.2f %% del total de los datos del dataset.", num_deleted_rows, num_deleted_rows*100/num_rows))
```

Se ha eliminado un porcentaje alto de registros. Se entiende que los outliers se han debido a problemas en el scraping al generar el dataset.


## Dataframe df_reviews: Detección y gestión de datos que contienen ceros o elementos vacíos

```{r}
# Guardamos número de filas antes de la limpieza
num_rows <- nrow(df_reviews)
# Guardamos contador de filas eliminadas
num_deleted_rows <- 0
```

Se comprueba si existen elementos vacíos.

```{r}
# ‘Not Available’ / Missing Values
colSums(is.na(df_reviews))
```

Se eliminan las reseñas sin comentarios.

```{r}
num_deleted_rows <- num_deleted_rows + nrow(df_reviews[is.na(df_reviews$comments),])
dim(df_reviews)
df_reviews <- df_reviews[!is.na(df_reviews$comments),]
# Comprobamos que se han eliminado registros
dim(df_reviews)
```

Se comprueba la existencia de elementos con valores en blanco.

```{r}
colSums(df_reviews=="")
```

Se eliminan las reseñas con valores en blanco.

```{r}
num_deleted_rows <- num_deleted_rows + nrow(df_reviews[df_reviews$comments == "",])
dim(df_reviews)
df_reviews <- df_reviews[!(df_reviews$comments == ""),]
# Comprobamos que se han eliminado registros
dim(df_reviews)
```

Se observa un registro con **reviewer_name** en blanco, pero no se trata porque no afecta al estudio.

## Dataframe df_reviews: Identificación y tratamiento de valores extremos

Se decide no hacer este estudio por la naturaleza de los datos (identificadores, fechas y texto libre).

Tras el proceso de limpieza, se tiene el siguiente balance:

```{r}
print(sprintf("El número total de filas eliminadas es %d, lo que representa el %.2f %% del total de los datos del dataset.", num_deleted_rows, num_deleted_rows*100/num_rows))
```


******
# Análisis de los datos
******

La tercera fase del ciclo de vida de los datos, después de su captura y tratamiento es su análisis con el objeto de extraer información de los mismos.

## Selección de los grupos de datos que se quieren  analizar/comparar (planificación de los análisis a aplicar)

Para contestar a las diferentes preguntas se requieren distintos tipos de análisis. A continuación, se muestra una tabla con los diferentes análisis a realizar:

|Pregunta   |Tipo de análisis|Variables analizadas |Visualización|
|:------|:--------------|:--------------|:------|
|¿Qué distritos tienen más alojamientos? |Univariante |listing.csv: neighbourhood_group |Plot|
|¿Qué tipo de alojamiento es el más frecuente? |Univariante |listing.csv: room_type |Plot| 
|¿Cuáles son las palabras más utilizadas en el título de los anuncios de alojamientos? |Multivariante |listing.csv: id, name - adjectives.csv: word |Nube de palabras| 
|¿Cuál es el precio medio para cada tipo de alojamiento? |Bivariante |listing.csv: price, room_type |Tabla|
|¿Qué tipo de alojamiento es el más frecuente por distrito? |Bivariante |listing.csv: neighbourhood_group, room_type |Plot|
|¿Qué distrito es el más caro? ¿Qué distrito es el más barato? ¿Existen diferencias significativas de precio para los diferentes distritos? |Bivariante. Test de normalidad, test de homocedasticidad, test de hipótesis. |listing.csv: neighbourhood_group, price, price_group (categorización de price) |Tabla, Plot| 
|¿Cuantos alojamientos por tipo de habitación y precio hay? ¿Existen diferencias significativas de precio para los diferentes tipos de alojamiento? |Bivariante. Test de normalidad, test de homocedasticidad, test de hipótesis. |listing.csv: room_type, price, price_group (categorización de price) |Plot|
|¿Existe relación entre el precio y el número de alojamientos de un mismo anfitrión? |Bivariante |listing.csv: price, calculated_host_listings_count |Matriz de correlación. Plot de correlación|
|¿Cuál es la densidad de alojamientos por distrito? ¿Qué distritos tienen una mayor densidad de alojamientos por habitante?|Multivariante |C5000121.xls:neighbourhood_group, population - listing.csv: neighbourhood_group, longitude,latitude|Plot, Diagrama de densidad|
|¿Existe una diferencia significativa entre el promedio de reseñas por mes para los alojamientos de tipo habitación privada y apartamento? |Bivariante: Test de normalidad, test de homocedasticidad, test de hipótesis. |listing.csv: reviews_per_month, room_type ||
|¿Existe una diferencia significativa entre los tipos de alojamiento por distrito? |Bivariante: test chi cuadrado |listing.csv: neighbourhood_group, room_type ||
|¿Se podría construir un modelo de regresión para predecir el precio del alojamiento en función de otras variables? |Multivariante |listing.csv: price, minimum_nights, reviews_per_month, availability_365, latitude, longitude |Plot de correlación|
|¿Cómo es la estacionalidad en el alquiler de alojamientos turísticos? |Univariante |reviews_detailed.csv: date |Plot|


### ¿Qué distritos tienen más alojamientos?

```{r}
# Mostramos plot con distritos ordenados por frecuencia
neighbourhood_group_freq <- data.frame(table(df_listings$neighbourhood_group))
ggplot(neighbourhood_group_freq, aes(x = reorder(Var1, -Freq), y = Freq)) +
  geom_segment(aes(x = reorder(Var1, - Freq), xend = reorder(Var1, - Freq), y = 0, yend = Freq), color = "gray", lwd = 1) +
  geom_point(size = 6, pch = 21, bg = 4, col = 1) +
  geom_text(aes(label=Freq), color = "white", size = 2) +
  xlab("Distrito") +
  ylab("Número de anuncios") +
  coord_flip()+
  theme_minimal()
```

Se observa que el distrito **Centro** es con mucha diferencia el que más anuncios tiene. Los siguientes distritos **Salamanca**, **Arganzuela**, **Chamberí** y **Tetúan** son distritos limítrofes al centro. Están todos en el interior de la M-30.

### ¿Qué tipo de alojamiento es el más frecuente?

```{r}
# Mostramos plot con alojamientos ordenados por frecuencia
room_type_freq <- data.frame(table(df_listings$room_type))
ggplot(room_type_freq, aes(x = reorder(Var1, -Freq), y = Freq)) +
  geom_segment(aes(x = reorder(Var1, - Freq), xend = reorder(Var1, - Freq), y = 0, yend = Freq), color = "gray", lwd = 1) +
  geom_point(size = 6, pch = 21, bg = 4, col = 1) +
  geom_text(aes(label=Freq), color = "white", size = 2) +
  xlab("Tipo de habitación") +
  ylab("Número de anuncios") +
  coord_flip()+
  theme_minimal()
```

El tipo de habitación más frecuente es **Entire home/apt**, seguido de **Private room**. Los usuarios de Airbnb dan mucha importancia a su privacidad, de ahí los bajos valores de las habitaciones compartidas. El resultado de las habitaciones de hotel es testimonial, ya que este tipo de alojamiento se ofertan en otras plataformas.

### ¿Cuáles son las palabras utilizadas en el título de los anuncios de alojamientos?

Se muestra el resultado con una nube de palabras.

```{r}
word_list <- strsplit(df_listings$name," ")
word_df <- data.frame(id = rep(df_listings$id, sapply(word_list, length)), word = tolower(unlist(word_list)))
word_summary <- as.data.frame(merge(word_df, df_adjectives, by.x = 'word', by.y = 'word', all = T))
colnames(word_summary) <- c('word', 'cnt_obs')
word_summary <- aggregate(cnt_obs~word, FUN = length, data = word_summary)
word_summary <- word_summary[!word_summary$word %in% c('la', 'con', 'en', '-', '&', 'a', 'with', 'el', '-', '2','in', 'de',' la', 'del', 'of', 'and', 'y', 'the', '1', 'city', 'to', 'para', 'for', 'near', '4','3','4','5','6','7','8','9','al','las','junto','/','at','.','muy','+',','), ]
word_summary <- head(arrange(word_summary, desc(cnt_obs)),100)
wordcloud(word_summary$word,
          word_summary$cnt_obs,
          max.words = 100,
          scale = c (9,.2), colors = brewer.pal(5, "Blues")[-(1:2)],
          rot.per=0,
          random.order=T)
```
Las palabras más utilizadas en los títulos de los anuncios de airbnb son: apartamento o habitación en el centro.

### ¿Qué tipo de alojamiento es el más frecuente por distrito?

```{r}
ggplot(df_listings,aes(neighbourhood_group ,fill=room_type)) + 
  geom_bar() +labs(x="Distrito", y="Tipo de alojamiento") + 
  guides(fill=guide_legend(title="")) + 
  ggtitle("Alojamientos por distrito") + 
  coord_flip()

ggplot(df_listings, aes(fill=room_type, x=neighbourhood_group, y = price))+
  geom_bar(position="fill",stat="identity") +
  labs(y= 'Alojamiento', x = 'Distrito') +
  guides(fill=guide_legend(title=""))+
  coord_flip()
```
Con la excepción de **Villaverde**, **Villa de Vallecas**, **Vicálvaro**, **San Blas - Canillejas**, **Moratalaz**,**Barajas** y **Ciudad Lineal**, en el resto de Madrid predomina el alquiler del apartamento completo en vez de habitaciones privadas o compartidas.


### ¿Qué distrito es más caro? ¿Qué distrito es más barato? ¿Existen diferencias significativas de precio para los diferentes distritos?

```{r}
# Obtenemos precio medio por distrito
df_mean_price_by_neighbourhood_group <- aggregate(df_listings$price, list(df_listings$neighbourhood_group), FUN=mean) 
# Ordenamos por precio
df_mean_price_by_neighbourhood_group[order(df_mean_price_by_neighbourhood_group[,2]),]
```
Se observa que **Villaverde** es el más barato y que **San Blas - Canillejas** y **Vicálvaro** son los más caros. Estos resultados son bastante extraños, ya que esas no son las zonas más caras de la capital.

¿Qué ocurre con **San Blas - Canillejas** y **Vicálvaro**?

```{r}
df_listings %>%
  ggplot(aes(x=neighbourhood_group, y=price, fill=neighbourhood_group))+
  geom_boxplot(show.legend=FALSE)+
  coord_flip()
```

En el diagrama de cajas se aprecia un gran número de valores extremos en el distrito de **San Blas-Canillejas**. Hay un motivo principal para esta distribución tan anómala, que también afecta en menor medida a **Vicálvaro** , **Moratalaz**, **Hortaleza**, **Fuencarral - El Pardo**, **Ciudad Lineal**, y **Barajas**, y es su cercanía al estadio Wanda Metropolitano, ya que debido a la celebración de la final de la Champions League en ese estadio en 2019 los precios se dispararon en la zona. Este hecho se ve reflejado en la variable price, que contiene el mayor precio al que se alquila (o alquiló) el alojamiento turístico.

Para solucionar este problema vamos a considerar valores extremos en estos distritos a cualquier valor por encima de 150 euros.

```{r}
df_listings <- df_listings[!(df_listings$neighbourhood_group=="San Blas - Canillejas" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Vicálvaro" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Barajas" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Moratalaz" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Hortaleza" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Barajas" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Fuencarral - El Pardo" & df_listings$price>150),]

# Obtenemos precio medio por distrito
df_mean_price_by_neighbourhood_group <- aggregate(df_listings$price, list(df_listings$neighbourhood_group), FUN=mean) 
# Ordenamos por precio
df_mean_price_by_neighbourhood_group[order(df_mean_price_by_neighbourhood_group[,2]),]
```
Se aprecia tras corregir como los distritos situados dentro de la almendra central son los más caros, con la excepción de **Moncloa - Aravaca** que es una de las zonas de lujo de la capital.

En los siguientes gráficos se observa la distribución de precios por distrito. Dividimos el precio en 5 grupos: **Muy bajo**, **Bajo**, **Moderado**, **Alto** y **Muy alto**.

```{r}

# Obtenemos cuantiles
quantile_price = integer(10)
for (i in 1:10) {
  quantile_price[i] = quantile(df_listings$price,i * 0.1) 
}
quantile_price
# Creamos campo nuevo con precio categorizado
df_listings <- df_listings %>% mutate(price_group=ifelse(price < quantile_price[2]+1, "Muy bajo",
                                                ifelse(price < quantile_price[4]+1, "Bajo",
                                                ifelse(price < quantile_price[6]+1, "Moderado",
                                                ifelse(price < quantile_price[8]+1, "Alto", "Muy alto"
                                                 )))))
ggplot(df_listings, aes(neighbourhood_group)) + 
  geom_bar(aes(fill = price_group)) + 
  ggtitle("Listings per price and neighbourhood group") +
  guides(fill=guide_legend(title="")) +
  coord_flip()

ggplot(df_listings, aes(x=neighbourhood_group, y=id, fill=price_group ))+
  geom_bar(position="fill", stat="identity")+
  labs(y="Price", x="Neighbourhood group")+
  guides(fill=guide_legend(title=""))+
  coord_flip()
```
En este último gráfico se aprecia la diferencia entre los precios por distritos. Mientras podemos encontrar alojamientos de cualquier tipo de precio en los distritos de la almendra central, los precios más baratos siempre están en el extrarradio.

```{r}
pal <- colorNumeric(palette=rainbow(6), domain=df_listings$price)
leaflet(data=df_listings)%>%
  addProviderTiles(providers$CartoDB.Positron)%>%
  addCircleMarkers(~longitude, ~latitude, color=~pal(price), weight=1, radius=1.5, fillOpacity=1, opacity=1,
                   label=paste("Neighbourhood:", df_listings$neighbourhood_group))%>%
  addLegend("bottomright", pal = pal, values =~price,
            title="Precio",
            opacity=1,)
```

Se comprueba si el precio sigue una distribución normal cont el test de **Kolmogorov-Smirnov**:

```{r}
is_normal_distribution <- function(x){ifelse(x >= 0.05, "Distribution normal", "NO es distribution normal")}
result <- ks.test(df_listings$price, pnorm, mean(df_listings$price), sd(df_listings$price))
is_normal_distribution(result$p.value)
```

Como la distribución no es normal, se comprueba la homocedasticidad del precio por distrito con el test de **Fligner-Killeen** (alternativa no paramétrica, utilizada cuando los datos no cumplen con la condición de normalidad): 

```{r}
is_homogeneous_variance <- function(x){ifelse(x >= 0.05, "Varianza homogénea", "Varianza NO homogénea")}

result <- fligner.test(price ~ neighbourhood_group, data = df_listings)
is_homogeneous_variance(result$p.value)
```

La variable **price** presenta varianzas estadísticamente diferentes para los diferentes distritos (**neighbourhood_group**).

La variable **price** no sigue una distribución normal y presenta varianzas estadísticamente diferentes para los diferentes distritos. Por este motivo, se usa el test de **Kruskal-Wallis**, que es la alternativa no paramétrica a los contrastes de hipótesis de más de 2 grupos para comprobar si el precio muestra diferencias significativas para los diferentes distritos. 

```{r}
kruskal.test(price ~ neighbourhood_group, data = df_listings)
```

El p-valor obtenido es menor al nivel de significancia (0.05), por tanto, se puede concluir que el precio (**price**) muestra diferencias significativas para los diferentes distritos (**neighbourhood_group**).

### ¿Cuál es el precio medio de cada tipo de alojamiento?

```{r}
mean_price_table <- aggregate(df_listings$price, list(df_listings$room_type), FUN=mean)
# Ordenamos por precio
mean_price_table[order(mean_price_table$x), ]

ggplot(df_listings, aes(x=price, fill=room_type))+
  geom_density(alpha=0.5)
```

Un alquiler de un apartamento completo tiene un precio similar al de una habitación de hotel, y es un 216% más caro que una habitación privada y un 228% más caro que una habitación compartida.


### ¿Cuantos alojamientos por tipo de habitación y precio hay? ¿Existen diferencias significativas de precio para los diferentes tipos de habitación?

```{r}
ggplot(df_listings, aes(room_type)) + geom_bar(aes(fill = price_group)) + ggtitle("Alojamientos por tipo de habitación y precio")
```

Se aprecia que los apartamentos completos tienen un rango de precios entre alto y muy alto. Las habitaciones privadas suelen ser de precio muy bajo - bajo, siendo las habitaciones compartidas generalmente de precio muy bajo.

Anteriormente, se comprobó que el precio no seguía una distribución normal. Se comprueba ahora la homocedasticidad del precio por tipo de habitación con el test de **Fligner-Killeen** (alternativa no paramétrica, utilizada cuando los datos no cumplen con la condición de normalidad): 

```{r}
result <- fligner.test(price ~ room_type, data = df_listings)
is_homogeneous_variance(result$p.value)
```

La variable **price** presenta varianzas estadísticamente diferentes para los diferentes  tipos de habitación (**room_type**).

La variable **price** no sigue una distribución normal y presenta varianzas estadísticamente diferentes para los diferentes tipos de habitación. Por este motivo, se aplica el test de **Kruskal-Wallis**, que es la alternativa no paramétrica a los contrastes de hipótesis de más de 2 grupos para comprobar si el precio muestra diferencias significativas para los diferentes tipos de habitación. 

```{r}
kruskal.test(price ~ room_type, data = df_listings)
```

El p-valor obtenido es menor al nivel de significancia (0.05), por tanto, se puede concluir que el precio (**price**) muestra diferencias significativas para los diferentes tipos de habitación (**room_type**).

### ¿Existe relación entre el precio y el número de casas/apartamentos de un anfitrión?

Se genera la matriz de correlación para las variables **price** y **calculated_host_listings_count**.

```{r}
df_aux <- subset(df_listings, select=c(price, calculated_host_listings_count))
str(df_aux)
correlacionMatrix <- cor(df_aux)
correlacionMatrix
```

Se observa que el coeficiente de correlación entre ambas variables es muy bajo (0.19) 


```{r}
# Mostramos plot de matriz de correlación
corrplot(correlacionMatrix,order = "hclust")
corrplot(correlacionMatrix, method = "number", tl.cex = 0.7,number.cex = 0.8, cl.pos = "n")
```

Por lo tanto, que un propietario tenga muchos alojamientos anunciados no tiene un impacto directo en el precio del alojamiento.

El siguiente gráfico  muestra como la mayoría de los propietarios tienen 1 alojamiento anunciado. Hay propietarios con hasta 163 alojamientos en airbnb

```{r}
ggplot(df_listings, aes(x=calculated_host_listings_count)) +
  geom_histogram(binwidth = 10, bins=10, col="blue", fill="blue")+
  labs(x="Alojamientos por propietario", y ="Numero de alojamientos") +
  ggtitle("Número de alojamientos por propietario") 

```

### ¿Qué distritos tienen una mayor densidad de alojamientos por habitante?

Para responder a esta pregunta se necesitan los datos de población por distrito cargados en el dataframe df_population.

Se limpia el dataframe.

```{r}
# Eliminamos  los cuatro primeros caracteres del campo neighbourhood_group
df_population$neighbourhood_group <- substring(df_population$neighbourhood_group, first = 5)
# Reemplazamos los guiones por guiones separados por espacios
df_population$neighbourhood_group <- gsub('-',' - ',df_population$neighbourhood_group)
tail(df_population)
```

Se unen los datos de población a la tabla de frecuencias de anuncios por distrito calculada anteriormente.

```{r}
head(neighbourhood_group_freq)
# Renombramos columnas de la tabla de frecuencias
colnames(neighbourhood_group_freq) <- c('neighbourhood_group', 'listings')
tail(neighbourhood_group_freq)
# Unimos datos de población
neighbourhood_group_freq <- join(neighbourhood_group_freq, df_population, type ='left')
head(neighbourhood_group_freq)
```

Se crea una nueva variable que almacene el número de habitantes por anuncio.

```{r}
neighbourhood_group_freq$density <- round(neighbourhood_group_freq$population / neighbourhood_group_freq$listings, 0)
tail(neighbourhood_group_freq)
```

Y se visualizan los datos.

```{r}
ggplot(neighbourhood_group_freq, aes(x = reorder(neighbourhood_group, -density), y = density)) +
  geom_segment(aes(x = reorder(neighbourhood_group, - density), xend = reorder(neighbourhood_group, - density), y = 0, yend = density), color = 'gray', lwd = 1) +
  geom_point(size = 6, pch = 21, bg = 4, col = 1) +
  geom_text(aes(label=density), color = 'white', size = 2) +
  xlab('District') +
  ylab('Número de habitantes por anuncio y distrito') +
  coord_flip()+
  theme_minimal()
```

En el distrito **Centro** hay un alojamiento por cada 17 habitantes. Los 4 siguientes distritos con menor número de habitantes por alojamiento turísticos están todos en la almendra central.
En **Villa de Vallecas** hay un alojamiento por cada 1234 habitantes. Todos los distritos con mayor número de habitantes por alojamiento turísticos están en el extrarradio.

Se genera un mapa para visualizar los resultados geográficamente. Se aplica una normalización logarítmica para reducir el rango de valores. 

```{r}
df_listings <- merge(df_listings, neighbourhood_group_freq, type='left')
ggplot(data=df_listings) +
  geom_point(aes(x=latitude, y=longitude, color = log10(density))) +
  ggtitle('Densidad de alojamientos turísticos por habitante')
```

El mapa nos permite apreciar la mayor densidad de alojamientos turísticos en la zona central de Madrid.

### ¿Existe una diferencia significativa entre el promedio de reseñas por mes para los alojamientos de tipo habitación privada y apartamento? 

Se seleccionan los registros para los alojamientos con habitación privada y apartamento completo. 

```{r}
df_aux <- subset(df_listings, room_type=="Private room" | room_type=="Entire home/apt")
head(df_aux)
```

Se comprueba la normalidad de la distribución para las reseñas por mes (**reviews_per_month**) con el test de **Kolmogorov-Smirnov**.

```{r}
result <- ks.test(df_aux$reviews_per_month, pnorm, mean(df_aux$reviews_per_month), sd(df_aux$reviews_per_month))
is_normal_distribution(result$p.value)
```

Como la distribución no es normal, se comprueba la homocedasticidad de las reseñas mensuales por tipo de habitación con el test de **Fligner-Killeen** (alternativa no paramétrica, utilizada cuando los datos no cumplen con la condición de normalidad): 

```{r}
result <- fligner.test(reviews_per_month ~ room_type, data = df_aux)
is_homogeneous_variance(result$p.value)
```

La variable **reviews_per_month** presenta varianzas estadísticamente diferentes para los diferentes tipos de habitación (**room_type**).

No se cumplen las condiciones de normalidad, ni de homocedasticidad, por lo que se usa el test de **Kruskal-Wallis**, que es la alternativa no paramétrica a los contrastes de hipótesis con el objetivo de comprobar si las reseñas por mes muestran diferencias significativas para los tipos de habitación seleccionados. 

```{r}
kruskal.test(reviews_per_month ~ room_type, data = df_aux)
```

El p-valor obtenido es menor al nivel de significancia (0.05), por tanto, se puede concluir que las reseñas por mes (**reviews_per_month**) muestran diferencias significativas para los tipos de habitación seleccionados (**room_type**).

### ¿Existe una diferencia significativa entre los tipos de habitación por distrito?

Para comparar si existen diferencias significativas en una variable categórica entre los grupos definidos por otra variable categórica, se puede aplicar el test chi cuadrado, mediante la función **chisq.test()**.

Se construye la tabla de contingencia para ambas variables.

```{r}
# Tabla de contingencia room_type y neighbourhood_group
conting <- table(df_listings$neighbourhood_group, df_listings$room_type)
conting
```

Se aplica el test chi cuadrado.

```{r}
chisq.test(conting)
```

El p-valor obtenido es menor al nivel de significancia (0.05), por tanto, se puede concluir que el tipo de habitación (**room_type**) muestra diferencias significativas para los diferentes distritos (**neighbourhood_group**).

### ¿Se podría construir un modelo de regresión para predecir el precio del alojamiento en función de otras variables?

Se ha comprobado anteriormente que la variable precio no sigue una distribución normal. 
Se transforma esta variable aplicando una función logarítmica para conseguir que se ajuste a una distribución normal

```{r}
# Se crea una nueva variable con el precio en escala logarítmica 
df_listings$price_trans <- log1p(df_listings$price)

# Se comprueba la normalidad de forma gráfica
ggplot(df_listings, aes(x=price_trans, fill = room_type))+
  geom_density(alpha=0.5)+
  ggtitle('Precio logarítmico transformado')
```

Se seleccionan las variables que vamosa  incluir en el modelo y comprobamos su correlación:

```{r}
df_reg <- df_listings[,c("price_trans", "minimum_nights", "reviews_per_month", "availability_365", "latitude", "longitude")]

# Mostramos plot de matriz de correlación
correlacionMatrix <- cor(df_reg)
correlacionMatrix

corrplot(corr = cor(correlacionMatrix, method = "pearson"), method = "number", tl.cex = 0.7,number.cex = 0.8, cl.pos = "n")
df_reg <-df_listings[,c("price_trans", "minimum_nights", "reviews_per_month", "availability_365", "latitude", "longitude","neighbourhood_group","neighbourhood","room_type")]
```

Se observa que la correlación entre el precio y el resto de las variables es bajo.

La correlación más alta se da entre **price** y **longitude**, pero es muy baja. No parece tener sentido intentar generar un modelo de regresión lineal que permita predecir el precio en función de la variable longitud.

Se crean variables dummy para las variables categóricas que van a entrar en el modelo: **room_type**, **
```{r}
# Dummy variables para room_type
dv = caret::dummyVars(~ room_type, data=df_reg)
dummy_room_type = data.frame(predict(dv, df_reg))

#Dummy variables para neighbourhood_group
dv = caret::dummyVars(~ neighbourhood_group, data=df_reg)
dummy_neighbourhood_group = data.frame(predict(dv, df_reg))

#Dummy variables para neighbourhood
dv = caret::dummyVars(~ neighbourhood, data=df_reg)
dummy_neighbourhood = data.frame(predict(dv, df_reg))

#Unimos y eliminamos las variables categóricas
df_reg2 <- cbind(df_reg, dummy_room_type, dummy_neighbourhood_group, dummy_neighbourhood)
df_reg2 <- select(df_reg2, - room_type, - neighbourhood_group, - neighbourhood)

#Creamos el modelo
model <- lm(price_trans ~ ., data=df_reg2)
summary(model)
```

La bondad del ajuste se mide con el parámetro Adjusted R-squared que es de 0.44, cuándo este valor es próximo a 1 es indicativo de un buen modelo de ajuste. Pero no es el caso de este modelo.

A continuación se evalúa su capacidad predictiva, creando un dataset de entrenamiento y test

```{r}
# Se crean los datasets de entrenamiento y test
n<-nrow(df_reg2)
train_index <- sample(seq_len(n), size = floor(0.75*n))
train <- df_reg2[train_index, ]
test <- df_reg2[-train_index, ]

# Se crea el modelo con los datos de entrenamiento
model <- lm(price_trans ~., data=train)

# Se comprueban sus resultados
par(mfrow=c(2,2))
plot(model)


```

Se interpreta lo siguiente de estos gráficos:

* Residuals vs Fitted - se aprecia la aleatoridad de los resultados y como la varianza es constante a lo largo del eje X.
* Normal Q-Q: muestra como los residuos se distribuyen de forma normal excepto al llegar al final del eje X. Es por ello que este modelo requiere un mejor ajuste.
* Scale-Location: muestra como se distribuyen los residuos, se aprecia que tienen la misma varianza.
* Residuals vs Leverage: sirve para encontrar observaciones que puedan influir en el resultado. No se aprecian puntos a eliminar.

```{r}
# Se crea la predicción de los datos de entrenamiento y se añaden al dataframe
prediction <- predict(model, test)

# Se calcula el error medio cuadrático de los residuos
rmse <- sqrt(sum((exp(prediction)-test$price_trans)^2)/length(test$price_trans))
c(RMSE = rmse, R2 = summary(model)$r.squared)

```

Un RMSE de 62 no es un buen resultado.

### ¿Cómo es la estacionalidad en el alquiler de alojamientos turísticos?

Para responder a esta pregunta hay que saber en qué momento del año se han producido los alquileres. Este dato no está disponible, pero se puede utilizar una aproximación sustituyendolo por la fecha en la que se ha hecho una reseña. Para ello se aplica el dataset **reviews_detailed.csv** que contiene un inventario de todas las reseñas realizadas.

Se convierte el campo date a tipo de datos fecha y se divide la fecha en año, mes, número de día y día de la semana.

```{r}
reviews_count <- df_reviews$date
reviews_count <- as.Date(reviews_count, "%Y-%m-%d")
reviews_count <- data.frame(date = reviews_count,
                            year = as.numeric(format(reviews_count, format = "%Y")),
                            month = as.numeric(format(reviews_count, format = "%m")),
                            day = as.numeric(format(reviews_count, format = "%d")))
reviews_count$weekday <- strftime(reviews_count$date, '%A')
head(reviews_count)
```

Se agrupa por año, mes y día de la semana para ver la evolución por cada tipo de variable.

```{r}
year <- aggregate(reviews_count$date, by = list(reviews_count$year), FUN = length)
colnames(year) <- c("Year","number_of_reviews")
month <- aggregate(reviews_count$date, by = list(reviews_count$month), FUN = length)
colnames(month) <- c("Month","number_of_reviews")
weekday <- aggregate(reviews_count$date, by = list(reviews_count$weekday), FUN = length)
colnames(weekday) <- c("Weekday", "number_of_reviews")

ggplot(reviews_count, aes(x=year)) +
  geom_bar(col ='black', fill = 'blue')+
  scale_x_discrete(limits = c(2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021)) +
  labs (title ="Reseñas por año", x = "Año", y ="Número de alojamientos")
```

Como se aprecia en el gráfico, el negocio de los alojamientos turísticos crecía de forma exponencial desde el año 2015. La brusca caída se debe a los efectos del COVID-19 en el año 2020, situación que continua en 2021. 

Nota: los últimos datos del dataset son de Abril de 2021, por lo que no se puede apreciar en el gráfico si hay recuperación con respecto a 2020 o no.

```{r}
ggplot(reviews_count, aes(x=month)) +
  geom_bar(col ='black', fill = 'blue')+
  scale_x_discrete(limits = c("Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre")) +
  labs (title ="Reseñas por mes", x = "Mes", y ="Número de alojamientos")+
  coord_flip()

```

Sorprende que las reseñas se mantienen más o menos constantes a lo largo del año. Aún más que sean los meses de verano donde menos reseñas se escriben. 

```{r}

ggplot(data=reviews_count, aes(x=weekday)) + 
  geom_bar(col='black', fill ='blue') +
  labs (title = "Reseñas por días", x = "Días", y="Número de alojamientos")
```

Mientras que las reseñas permanecen constante a lo largo de los días de la semana, se ve un fuerte incremento en los domingos y lunes, lo que nos indica que los fines de semana es cuando más se reservan los alojamientos turísticos.


******
# Conclusiones
******

Atendiendo a las respuestas obtenidas en todas y cada una de las preguntas que se han realizado se llegan a las siguientes conclusiones:

**- ¿Qué tipo de vivienda comprar?**

Viviendas de segunda mano, de tamaño mediano-pequeño, a reformar.

El hecho de comprar viviendas de segundo mano se explica por la ausencia de promociones de obra nueva en las zonas de interés. Se explica en el siguiente punto cuáles son estas zonas.

Viviendas de tamaño mediano-pequeño, ya que la vivienda preferida por los usuarios de airbnb son los apartamentos enteros. El precio se incrementa hasta un 202% con respecto a alquilar una habitación compartida. Para compensar esto, se requerirían varias habitaciones privadas en el mismo inmueble, pero implicaría inmuebles más caros de comprar y de reformar.

En el análisis de palabras más utilizadas en los anuncios se observan muchos términos relacionados con la localización y tipo de inmueble, pero también hay adjetivos como: stylish, acogedor, precioso, beautiful, cozy, luxury, lovely, luminosa, spacious, lo que indica una necesidad de transformar los inmuebles de acuerdo a las tendencias de decoración minimalista actuales.

**- ¿En qué zona de la capital?**

Viviendas en la zona de la almendra central pero fuera del **Centro** debido a la saturación del mismo (17 habitantes por alojamiento turístico).

Se recomiendan oportunidades en barrios más caros como **Chamberí**, **Salamanca**, y **Retiro**, y centrar los esfuerzos en adquirir imuebles en zonas de la almendra central con menor coste: 
**Arganzuela**, **Tetuán**, **Chamartín**. Otra opción muy interesante por precio y su proximidad al aeropuerto sería **Barajas**.

Las oportunidades serían ventas de inmuebles ya destinados al alquiler turístico en el que la inversión por reforma no sería necesaria. Sería posible encontrar estas oportunidades debido a los efectos de la pandemia.

**- ¿Qué destino se le va a dar al inmueble?**

La inversión debe destinarse al alquiler turístico. Es un mercado que hasta la pandemia de COVID-19 crecía de forma exponencial y al que se ven signos de recuperación. 

Según las (estadísticas del Ayuntamiento de Madrid)[http://www-2.munimadrid.es/CSE6/control/seleccionDatos?numSerie=05040201030] la superficie media de la vivienda en Madrid es de 82 m2. 

Según el portal (idealista)[https://www.idealista.com/sala-de-prensa/informes-precio-vivienda/alquiler/madrid-comunidad/madrid-provincia/madrid/] el precio medio del alquiler en Madrid en Noviembre de 2021 es de 14,6 euros/metro cuadrado. Por lo tanto, el precio medio del aquiler tradicional es de 1197 euros al mes.

En este ejercicio se ha comprobado que el precio medio del alquiler turístico es de 88 euros/noche, por lo que llegaría a los 2640 euros al mes (considerando 30 días). Un 220% más.

El análisis de estacionalidad del alquiler turístico también nos muestra homogeneidad a lo largo de los meses y una alta ocupación durante todos los días de la semana.


******
# Contribución
******

|Contribuciones   |Firma|
|:------|:--------------|
|Investigación previa| BLB, GRF|
|Redacción de las respuestas| BLB, GRF|
|Desarrollo del código| BLB, GRF|

