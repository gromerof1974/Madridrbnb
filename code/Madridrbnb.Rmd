---
title: 'Tipología y ciclo de vida de los datos - Madrid Airbnb Data'
author: "Autores: Beatriz Lozano Ballesteros / Gabriel Romero Fernandez"
date: "Diciembre 2021"
output:
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 4
    includes:
      in_header: UOC_header.html
  pdf_document:
    highlight: zenburn
    toc: yes
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=T, echo=T)
```


```{r echo=TRUE}
# Carga de librerías
if (!require(summarytools)){
  install.packages('summarytools', repos='http://cran.us.r-project.org')
  library(summarytools)
} 
if(!require(tidyverse)){
  install.packages('tidyverse', repos='http://cran.us.r-project.org')
  library(tidyverse)
}
if(!require(caret)){
  install.packages('caret', repos='http://cran.us.r-project.org')
  library(caret)
}
if(!require(corrplot)){
  install.packages('corrplot', repos='http://cran.us.r-project.org')
  library(corrplot)
}
if(!require(wordcloud)){
  install.packages('wordcloud', repos='http://cran.us.r-project.org')
  library(wordcloud)
}
if(!require(Rcpp)){
  install.packages('Rcpp', repos='http://cran.us.r-project.org')
  library(Rcpp)
}
if(!require(xlsx)){
  install.packages('xlsx', repos='http://cran.us.r-project.org')
  library(xlsx)
}
if(!require(plyr)){
  install.packages('plyr', repos='http://cran.us.r-project.org')
  library(plyr)
}
if(!require(BSDA)){
  install.packages('BSDA', repos='http://cran.us.r-project.org')
  library(BSDA)
}
if(!require(leaflet)){
  install.packages('leaflet', repos='http://cran.us.r-project.org')
  library(leaflet)
}
if(!require(tm)){
  install.packages('tm', repos='http://cran.us.r-project.org')
  library(tm)}
```

******
# Descripción del dataset
******

Madrid se ha convertido en uno de los destinos predilectos de la inversión inmobiliaria mexicana. El idioma, los lazos culturales entre ambos países, la oferta gastronómica, así como la seguridad jurídica y ciudadana, entre otros atractivos, han provocado el interés del capital inversor mexicano en la capital de España.

Una conocida firma de inversión inmobiliaria mexicana ha pedido realizar un estudio sobre la situación del mercado inmobiliario en la ciudad de Madrid. El problema a resolver es sencillo: ¿Dónde invertir? 

El inversor quiere respuesta a estas preguntas:

  - ¿Qué tipo de vivienda comprar?
  - ¿En qué zona de la capital?
  - ¿Qué destino se le va a dar al inmueble? Entre las opciones de alquiler turístico y tradicional.
  
Es un hecho conocido que el mercado de alquiler se encuentra en franco retroceso debido al auge de los alquileres turísticos. Los propietarios han cambiado el alquiler tradicional por el turístico, espoleado por compañías de impacto mundial como **AirBnB**. El efecto sobre el alquiler tradicional ha sido nefasto. Por un lado, la oferta de alquileres se ha reducido, lo que ha tenido un gran impacto en los precios, y por otro lado ha generado un flujo de habitantes hacia las zonas periféricas de la capital. El centro de la ciudad es de los turistas.

Debido a esto, y para dar respuesta a nuestro inversor mexicano, se utilizan datos de [AirBnB en Madrid](https://www.kaggle.com/rusiano/madrid-airbnb-data).

De todos los datos disponibles en este repositorio se utilizan los siguientes datasets:

- [listings.csv](https://www.kaggle.com/rusiano/madrid-airbnb-data?select=listings.csv): contiene información sobre los anuncios de alojamientos turísticos de Airbnb en Madrid (Ver [diccionario de datos](https://docs.google.com/spreadsheets/d/1iWCNJcSutYqpULSQHlNyGInUvHg2BoUGoNRIGa6Szc4/edit#gid=982310896))

- [reviews_detailed.csv](https://www.kaggle.com/rusiano/madrid-airbnb-data?select=reviews_detailed.csv): detalle de las reseñas por anuncio.

También se utilizará el siguiente dataset:

- [C5000121.xls](https://www.madrid.es/UnidadesDescentralizadas/UDCEstadistica/Nuevaweb/Demograf%C3%ADa%20y%20población/Indicadores%20Demográficos/C5000121.xls): datos de población por distrito.

El mejor enfoque para poder proporcionar una respuesta adecuada a un problema complejo, es dividir el problema en partes más pequeñas, más sencillas de responder, es por ello que se definen una serie de preguntas más específicas. Estas preguntas se hacen desde dos ángulos distintos: por un lado queremos analizar el aspecto geográfico, ¿dónde invertir?, y por otro lado lo concerniente al tipo de alojamiento a comprar ¿Qué comprar y para qué?.

Un poco de geografía: La ciudad de Madrid se divide en 21 distritos. La presencia de la carretera de circunvalación M-30 actúa como barrera geográfica entre los distritos de la almendra central (interior) de los del extrarradio. Dentro de la almendra central se encuentran los siguientes distritos (entre corchetes el precio de alquiler tradicional según el portal [Idealista] a Noviembre de 2020 (https://www.idealista.com/sala-de-prensa/informes-precio-vivienda/alquiler/madrid-comunidad/madrid-provincia/madrid/)): **Centro** [17,5 euros/m2], **Tetuán** [15,0 euros/m2], **Chamartín** [15,4 euros/m2], **Chamberí** [17,1 euros/m2], **Salamanca** [17,5 euros/m2], **Retiro** [15,0 euros/m2] y **Arganzuela** [14,6 euros/m2]. 

En el extrarradio tenemos los siguientes distritos: **Barajas** [11,4 euros/m2], **Carabanchel** [11,7 euros/m2], **Ciudad Lineal** [12,8 euros/m2], **Fuencarral** [15,4 euros/m2],**Hortaleza** [12,5 euros/m2], **Latina** [11,8 euros/m2], **Moncloa** [14,3 euros/m2], **Moratalaz** [10,9 euros/m2], **Puente de Vallecas** [12,1 euros/m2], **San Blas** [11,4 euros/m2], **Usera** [11,5 euros/m2], **Vicálvaro** [10,4 euros/m2], **Villa de Vallecas** [11,2 euros/m2], **Villaverde** [10,9 euros/m2].

Estas son las preguntas relativas a la geografía de Madrid: 

- ¿Qué distritos tienen más alojamientos?

- ¿Qué tipo de alojamiento es el más frecuente por distrito?

- ¿Existen diferencias significativas de precio para los diferentes distritos?

- ¿Cúal es la densidad de alojamientos por distrito? ¿Qué distritos tienen una mayor densidad de alojamientos por habitante?

- ¿Existe una diferencia significativa entre los tipos de alojamiento por distrito?

Airbnb oferta 4 tipos de alojamientos: alojamiento completo, habitación privada, habitación compartida y habitación de hotel.Las preguntas a responder en este grupo son:

- ¿Qué tipo de alojamiento es el más frecuente?

- ¿Cuál es el precio medio de cada tipo de alojamiento?

- ¿Cuáles son las palabras más utilizadas en los títulos de los anuncios de alojamientos?

- ¿Cuantos alojamientos por tipo de habitación y precio hay? ¿Existen diferencias significativas de precio para los diferentes tipos de habitación?

- ¿Existe una diferencia significativa entre el promedio de reseñas por mes para los alojamientos de tipo habitación privada y apartamento?

- ¿Cómo es la estacionalidad en el alquiler de alojamientos turísticos?

- ¿Se podría construir un modelo para predecir el precio del alojamiento en función de otras variables?

Para responder a todas estas preguntas se usan técnicas de ciencia de datos. Todo comienza con la carga de los mismos.

## Carga de los datasets

### listings.csv

```{r}
# Limpiamos el workspace
rm(list = ls())

# Cargamos datasets 
df_listings <- read.csv('listings.csv', encoding = "UTF-8")

df_reviews <- read.csv('reviews_detailed.csv', header = TRUE)

df_population <- read.xlsx('C5000121.xls',sheetIndex=1, startRow=11, endRow=31, as.data.frame=TRUE, header=FALSE, colIndex=c(2,3))
colnames(df_population) <- c('neighbourhood_group', 'population')
```

Se carga el dataset y se visualiza su estructura.

```{r}
print(dfSummary(df_listings), method = 'render')
```

El Data Frame Summary muestra la siguiente información:

- **Dimensiones**: 19618 registros x 16 variables.
- **Duplicados**: 0.
- **Valores nulos (columna Missing)**: para la variable 14, reviews_per_month [numeric], hay 5637 valores perdidos, que representan el 28.7%.

También se muestra las estadísticas de cada variable, las frecuencias de los valores de las variables, gráficos con la distribución de frecuencias, y número y porcentaje de valores válidos de cada variable. Salvo para la variable **reviews_per_month**, los valores válidos son el 100% para el resto de las variables. 

Tenemos 6 variables discretas de tipo character:

- **name**: descripción del alojamiento.

- **host_name**: nombre del anfitrión (por lo general, sólo el nombre).

- **neighbourhood_group**: distrito. Toma 21 valores diferentes. Se observa que el 44.1% de los alojamientos están en el distrito Centro.

- **neighbourhood**: barrio. Toma 128 valores diferentes.

- **room_type**: tipo de alojamiento Toma 4 valores diferentes. Se observa que el 57.7% es para apartamento completo (Entire home/apt) y el 39.8% para habitación privada (Private room).

- **last_review**: fecha de la ultima reseña. La cadena vacía representa que no hay reseña.

Tenemos 10 variables numéricas:

- **id**: identificador del anuncio.

- **host_id**: identificador del anfitrión.

- **latitude**: latitud según el Sistema Geodésico Mundial (WGS84).

- **longitude**: longitud según el Sistema Geodésico Mundial (WGS84).

- **price**: precio diario en moneda local.

Se observa que el precio mínimo es 0, y el máximo 9999, lo que podría estar indicando que la ausencia de valores se ha codificado como 0 ó 9999, dependiendo del caso. Estos valores aparecerán como outliers (valores extremos).

- **minimum_nights**: cantidad mínima de noches de estancia para el alojamiento (las reglas del calendario pueden ser diferentes). El valor máximo toma un valor excesivamente alto (1125), lo que podría estar indicando una captura errónea del dato. Estos valores aparecerán como outliers.

- **number_of_reviews**: número de reseñas del anuncio.

- **reviews_per_month**: número de reseñas que tiene el anuncio durante su vida útil

- **calculated_host_listings_count**: Número de casas / apartamentos completos que tiene el anfitrión en el scrape actual, en la geografía de la ciudad / región. Observamos que el anfitrión con más alojamientos tiene 163.

- **availability_365**: Disponibilidad 365 días según determine el calendario. Hay que tener en cuenta que un anuncio puede no estar disponible porque ha sido reservado por un invitado o bloqueado por el anfitrión.

Es el principal dataset que se va a emplear en este análisis.

### reviews_detailed.csv

```{r}
print(dfSummary(df_reviews), method = 'render')
```

- **Dimensiones**: 625006 registros x 6 variables.
- **Duplicados**: 0.
- **Valores nulos (columna Missing)**: para la variable 6, comments [character], hay 4 valores perdidos.

Hay 3 variables discretas de tipo character:

- **date**: fecha de la reseña.

- **reviewer_name**: nombre del cliente que deja la reseña.

- **comments **: comentarios del cliente.

Y 3 variables numéricas:

- **listing_id **: identificador del anuncio.

- **id**: identificador de la reseña.

- **reviewer_id**: identificador del cliente que deja la reseña.

Este dataset se utilizará para analizar la evolución temporal del alquiler turístico.

### C5000121.xls

```{r}
print(dfSummary(df_population), method = 'render')
```

- **Dimensiones**: 21 registros x 2 variables.
- **Duplicados**: 0.
- **Valores nulos (columna Missing)**: no hay valores perdidos.

Hay 1 variable discreta de tipo character:

- **neighbourhood_group **: distrito.

Y 1 variable numérica:

- **population**: número de habitantes.

Este dataset se empleará para calcular la densidad de población por alojamiento turístico.

******
# Limpieza de los datos
******

Una vez cargados los datos y analizado el contenido de cada dataset, se procede a su limpieza y normalización.

## Dataframe df_listings: Detección y gestión de datos que contienen ceros o elementos vacíos

```{r}
# Guardamos número de filas antes de la limpieza
dim_ini <- nrow(df_listings)
```

Se comprueba la existencia de elementos vacíos.

```{r}
# ‘Not Available’ / Missing Values
colSums(is.na(df_listings))
```

Se observa que **reviews_per_month** es la única variable a la que le faltan valores. 
Que no haya reseñas no parece ser un error y se puede considerar un valor legítimo, por lo que se sustituyen los valores no disponibles por 0.

```{r}
df_listings$reviews_per_month[which(is.na(df_listings$reviews_per_month))] <- 0
# Comprobamos que tras la sustitución ya no hay elementos vacíos
colSums(is.na(df_listings))
```

Se comprueba si existen elementos con valores en blanco.

```{r}
colSums(df_listings=="")
```

Existen elementos con valores en blanco (**name**, **host_name** y **last_review**), pero no los vamos a tratar porque estas variables no se van a utilizar en el análisis posterior, a excepción de **name**, pero el hecho de que tenga tres valores en blanco no afecta al estudio.

Se comprueba si existen elementos con valores iguales a cero.

```{r}
colSums(df_listings==0)
```

Las variables **number_of_reviews**, **reviews_per_month**, **availability_365** y **price** tienen valores a cero. 

Para **number_of_reviews**, 0 se puede considerar un valor legítimo (no hay reseñas).

**reviews_per_month** la tratamos anteriormente y se determinó que 0 se podía considerar un valor legítimo. Si no hay reseñas, el acumulado está también a cero.

En el caso de **availability_365**, tal y como indicaba el [diccionario de datos](https://docs.google.com/spreadsheets/d/1iWCNJcSutYqpULSQHlNyGInUvHg2BoUGoNRIGa6Szc4/edit#gid=982310896), hay que tener en cuenta que un anuncio puede no estar disponible porque ha sido reservado por un invitado o bloqueado por el anfitrión, por lo que cero se puede considerar un valor legítimo.

Sin embargo, para **price**, el valor cero no parece tener sentido, ya que se estaría hablando de alojamiento gratuito. En este caso, no se tendrán en cuenta los registros con **price=0**.

```{r}
dim(df_listings)
df_listings <- df_listings[!(df_listings$price == 0),]
# Comprobamos que se han eliminado registros
dim(df_listings)
```

## Dataframe df_listings: Identificación y tratamiento de valores extremos

En la descripción del dataset, se observan dos variables con valores que llamaban la atención por tomar valores muy altos: **price** y **minimum_nights**.

**price**: el precio máximo es 9999, lo que podría estar indicando que la ausencia de valores se ha podido codificar como 9999 o que se trata de un error en el scrape. Estos valores aparecerán como outliers.

```{r}
ggplot() + 
  geom_boxplot(aes(y = df_listings$price), fill='#4271AE', outlier.colour='red', alpha=0.9) + 
  scale_x_discrete( ) + 
  labs(title = "Precio diario en euros", y = "Precio") +
  coord_flip()
```

Se eliminan los outliers por distrito. Para ello se determina un límite de precio máximo en el percentil 95 de los precios de cada distrito, y se eliminan todos los registros por encima de ese valor.

```{r}
# Se define una función para hacer la limpieza
clean_price <- function(district_name){
  district <- df_listings[df_listings$neighbourhood_group==district_name,]
  district.quantile <- quantile(district$price, probs=c(.95), na.rm=T)
  df_listings <- df_listings[df_listings$neighbourhood_group!=district_name | (df_listings$neighbourhood_group==district_name & df_listings$price<district.quantile),]
  return(df_listings)
}

dim(df_listings)

# Se limpian todos los distritos
df_listings = clean_price("Centro")
df_listings = clean_price("Arganzuela") 
df_listings = clean_price("Retiro") 
df_listings = clean_price("Salamanca") 
df_listings = clean_price("Chamartín") 
df_listings = clean_price("Tetuán") 
df_listings = clean_price("Chamberí") 
df_listings = clean_price("Fuencarral - El Pardo") 
df_listings = clean_price("Moncloa - Aravaca") 
df_listings = clean_price("Latina") 
df_listings = clean_price("Carabanchel") 
df_listings = clean_price("Usera") 
df_listings = clean_price("Puente de Vallecas") 
df_listings = clean_price("Moratalaz") 
df_listings = clean_price("Ciudad Lineal") 
df_listings = clean_price("Hortaleza") 
df_listings = clean_price("Villa de Vallecas") 
df_listings = clean_price("Vicálvaro") 
df_listings = clean_price("San Blas - Canillejas") 
df_listings = clean_price("Barajas")
df_listings = clean_price("Villaverde")

dim(df_listings)
```

Tras la limpieza se obtiene el siguiente boxplot:

```{r}
ggplot() + 
  geom_boxplot(aes(y = df_listings$price), fill='#4271AE', outlier.colour='red', alpha=0.9) + 
  scale_x_discrete( ) + 
  labs(title ="Precio diario en euros", y = "Precio") +
  coord_flip()
```

Obtenemos el precio medio por distrito y ordenamos por precio.

```{r}
# Obtenemos precio medio por distrito
df_mean_price_by_neighbourhood_group <- aggregate(df_listings$price, list(df_listings$neighbourhood_group), FUN=mean) 
# Ordenamos por precio
df_mean_price_by_neighbourhood_group[order(df_mean_price_by_neighbourhood_group[,2]),]
```

Se observa que **Puente de Vallecas** es el más barato y que **San Blas - Canillejas** y **Vicálvaro** son los más caros. Estos resultados son bastante extraños, ya que esas no son las zonas más caras de la capital.

¿Qué ocurre con **San Blas - Canillejas** y **Vicálvaro**?

```{r}
df_listings %>%
  ggplot(aes(x=neighbourhood_group, y=price, fill=neighbourhood_group))+
  geom_boxplot(show.legend=FALSE)+
  coord_flip()
```

En el diagrama de cajas se aprecia un gran número de valores extremos en el distrito de **San Blas-Canillejas**. Hay un motivo principal para esta distribución tan anómala, que también afecta en menor medida a **Vicálvaro** , **Moratalaz**, **Hortaleza**, **Fuencarral - El Pardo**, **Ciudad Lineal**, y **Barajas**, y es su cercanía al estadio Wanda Metropolitano, ya que debido a la celebración de la final de la Champions League en ese estadio en 2019 los precios se dispararon en la zona. Este hecho se ve reflejado en la variable price, que contiene el mayor precio al que se alquila (o alquiló) el alojamiento turístico.

Para solucionar este problema vamos a considerar valores extremos en estos distritos a cualquier valor por encima de 150 euros.

```{r}
df_listings <- df_listings[!(df_listings$neighbourhood_group=="San Blas - Canillejas" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Vicálvaro" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Moratalaz" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Hortaleza" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Fuencarral - El Pardo" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Ciudad Lineal" & df_listings$price>150),]
df_listings <- df_listings[!(df_listings$neighbourhood_group=="Barajas" & df_listings$price>150),]

# Obtenemos precio medio por distrito
df_mean_price_by_neighbourhood_group <- aggregate(df_listings$price, list(df_listings$neighbourhood_group), FUN=mean) 
# Ordenamos por precio
df_mean_price_by_neighbourhood_group[order(df_mean_price_by_neighbourhood_group[,2]),]
```

Se aprecia tras corregir como los distritos situados dentro de la almendra central son los más caros, con la excepción de **Moncloa - Aravaca** que es una de las zonas de lujo de la capital.

```{r}
ggplot() + 
  geom_boxplot(aes(y = df_listings$price), fill='#4271AE', outlier.colour='red', alpha=0.9) + 
  scale_x_discrete( ) + 
  labs(title ="Precio diario en euros", y = "Precio") +
  coord_flip()
```

**minimum_nights**: el valor máximo toma un valor excesivamente alto (1125), lo que podría estar indicando una captura errónea del dato. Estos valores aparecerán como outliers.

```{r}
ggplot() + 
  geom_boxplot(aes(y = df_listings$minimum_nights), fill='#4271AE', outlier.colour='red', alpha=0.9) + 
  scale_x_discrete( ) + 
  labs(title = "Número mínimo de noches", y = "Número de noches") + 
  coord_flip()

```

El Plan Especial de Hospedaje (PEH), que entró en vigor tras su aprobación definitiva en el Pleno municipal del 27 de marzo de 2019, limita a **90 días** la posibilidad de alquilar una vivienda con **fines turísticos** sin permiso y a partir de ese plazo obliga a obtener una licencia de uso terciario de hospedaje. Esta medida afecta al 95% de los pisos de uso turístico.

Se decide no eliminar registros, en este caso de valores superiores a 90, sino limitar estos registros a un máximo de 90 noches al año.

```{r}
df_listings$minimum_nights[df_listings$minimum_nights > 90] <- 90
```

Tras la limpieza se obtiene el siguiente boxplot:

```{r}
ggplot() + 
  geom_boxplot(aes(y = df_listings$minimum_nights), fill='#4271AE', outlier.colour='red', alpha=0.9) + 
  scale_x_discrete( ) + 
  labs(title = "Número mínimo de noches", y = "Número de noches") + 
  coord_flip()
```

Los outliers se consideran válidos al haber propietarios que requieran mayor estabilidad en el alquiler.

Tras el proceso de limpieza, tenemos el siguiente balance:

```{r}
num_deleted_rows <- dim_ini - nrow(df_listings)
print(sprintf("El número total de filas eliminadas es %d, lo que representa el %.2f %% del total de los datos del dataset.", num_deleted_rows, num_deleted_rows*100/dim_ini))
```

Se ha eliminado un porcentaje bajo de registros. Se entiende que los outliers se han debido a problemas en el scraping al generar el dataset.


## Dataframe df_reviews: Detección y gestión de datos que contienen ceros o elementos vacíos

```{r}
# Guardamos número de filas antes de la limpieza
dim_ini <- nrow(df_reviews)
```

Se comprueba si existen elementos vacíos.

```{r}
# ‘Not Available’ / Missing Values
colSums(is.na(df_reviews))
```

Se eliminan las reseñas sin comentarios.

```{r}
dim(df_reviews)
df_reviews <- df_reviews[!is.na(df_reviews$comments),]
# Comprobamos que se han eliminado registros
dim(df_reviews)
```

Se comprueba la existencia de elementos con valores en blanco.

```{r}
colSums(df_reviews=="")
```

Se eliminan las reseñas con valores en blanco.

```{r}
dim(df_reviews)
df_reviews <- df_reviews[!(df_reviews$comments == ""),]
# Comprobamos que se han eliminado registros
dim(df_reviews)
```

Se observa un registro con **reviewer_name** en blanco, pero no se trata porque no afecta al estudio.

## Dataframe df_reviews: Identificación y tratamiento de valores extremos

Se decide no hacer este estudio por la naturaleza de los datos (identificadores, fechas y texto libre).

Tras el proceso de limpieza, se tiene el siguiente balance:

```{r}
num_deleted_rows <- dim_ini - nrow(df_reviews)
print(sprintf("El número total de filas eliminadas es %d, lo que representa el %.2f %% del total de los datos del dataset.", num_deleted_rows, num_deleted_rows*100/dim_ini))
```

## Otros tratamientos

### Dataframe df_population: Normalización de los nombres de los distritos 

Se limpia el dataframe para posteriormente poder unir esos datos con los de df_listing usando **neighbourhood_group**.

```{r}
# Eliminamos  los cuatro primeros caracteres del campo neighbourhood_group
df_population$neighbourhood_group <- substring(df_population$neighbourhood_group, first = 5)
# Reemplazamos los guiones por guiones separados por espacios
df_population$neighbourhood_group <- gsub('-',' - ',df_population$neighbourhood_group)
tail(df_population)
```

******
# Análisis de los datos
******

La tercera fase del ciclo de vida de los datos, después de su captura y tratamiento es su análisis con el objeto de extraer información de los mismos.

## Selección de los grupos de datos que se quieren  analizar/comparar (planificación de los análisis a aplicar)

Para contestar a las diferentes preguntas se requieren distintos tipos de análisis. A continuación, se muestra una tabla con los diferentes análisis a realizar:

|Pregunta   |Tipo de análisis|Variables analizadas |Visualización|
|:------|:--------------|:--------------|:------|
|¿Qué distritos tienen más alojamientos? |Univariante |listing.csv: neighbourhood_group |Plot|
|¿Qué tipo de alojamiento es el más frecuente? |Univariante |listing.csv: room_type |Plot| 
|¿Cuáles son las palabras más utilizadas en el título de los anuncios de alojamientos? |Univariante |listing.csv: name|Nube de palabras| 
|¿Cuál es el precio medio para cada tipo de alojamiento? |Bivariante |listing.csv: price, room_type |Tabla|
|¿Qué tipo de alojamiento es el más frecuente por distrito? |Bivariante |listing.csv: neighbourhood_group, room_type |Plot|
|¿Existen diferencias significativas de precio para los diferentes distritos? |Bivariante. Test de normalidad, test de homocedasticidad, test de hipótesis. |listing.csv: id, neighbourhood_group, price, price_group (categorización de price) |Tabla, Plot| 
|¿Cuantos alojamientos por tipo de habitación y precio hay? ¿Existen diferencias significativas de precio para los diferentes tipos de alojamiento? |Bivariante. Test de normalidad, test de homocedasticidad, test de hipótesis. |listing.csv: room_type, price, price_group (categorización de price) |Plot|
|¿Cuál es la densidad de alojamientos por distrito? ¿Qué distritos tienen una mayor densidad de alojamientos por habitante?|Multivariante |C5000121.xls:neighbourhood_group, population - listing.csv: neighbourhood_group, longitude,latitude|Plot, Diagrama de densidad|
|¿Existe una diferencia significativa entre el promedio de reseñas por mes para los alojamientos de tipo habitación privada y apartamento? |Bivariante: Test de normalidad, test de homocedasticidad, test de hipótesis. |listing.csv: reviews_per_month, room_type ||
|¿Existe una diferencia significativa entre los tipos de alojamiento por distrito? |Bivariante: test chi cuadrado |listing.csv: neighbourhood_group, room_type ||
|¿Se podría construir un modelo de regresión para predecir el precio del alojamiento en función de otras variables? |Multivariante |listing.csv: price, minimum_nights, reviews_per_month, availability_365, latitude, longitude |Plot de correlación|
|¿Cómo es la estacionalidad en el alquiler de alojamientos turísticos? |Univariante |reviews_detailed.csv: date |Plot|


## Selección de datos importantes y exportación a fichero

Una vez realizada la limpieza y determinados los datos que se necesitan para el análisis, se guardan.

```{r}
df_listings <- df_listings[, c("id", "name", "neighbourhood_group", "latitude", "longitude", "room_type", "price", "minimum_nights", "reviews_per_month", "availability_365")]
write.csv(df_listings, "listings_clean.csv")

df_reviews <- df_reviews[, c("listing_id", "date")]
write.csv(df_listings, "reviews_detailed_clean.csv")
```

## Pruebas estadísticas

### ¿Qué distritos tienen más alojamientos?

```{r}
# Mostramos plot con distritos ordenados por frecuencia
neighbourhood_group_freq <- data.frame(table(df_listings$neighbourhood_group))
ggplot(neighbourhood_group_freq, aes(x = reorder(Var1, -Freq), y = Freq)) +
  geom_segment(aes(x = reorder(Var1, - Freq), xend = reorder(Var1, - Freq), y = 0, yend = Freq), color = "gray", lwd = 1) +
  geom_point(size = 6, pch = 21, bg = 4, col = 1) +
  geom_text(aes(label=Freq), color = "white", size = 2) +
  xlab("Distrito") +
  ylab("Número de anuncios") +
  coord_flip()+
  theme_minimal()
```

Se observa que el distrito **Centro** es con mucha diferencia el que más anuncios tiene. Los siguientes distritos **Salamanca**, **Chamberí**, **Arganzuela** y **Tetúan** son distritos limítrofes al centro. Están todos en el interior de la M-30.

### ¿Qué tipo de alojamiento es el más frecuente?

```{r}
# Mostramos plot con alojamientos ordenados por frecuencia
room_type_freq <- data.frame(table(df_listings$room_type))
ggplot(room_type_freq, aes(x = reorder(Var1, -Freq), y = Freq)) +
  geom_segment(aes(x = reorder(Var1, - Freq), xend = reorder(Var1, - Freq), y = 0, yend = Freq), color = "gray", lwd = 1) +
  geom_point(size = 8, pch = 21, bg = 4, col = 1) +
  geom_text(aes(label=Freq), color = "white", size = 2) +
  xlab("Tipo de habitación") +
  ylab("Número de anuncios") +
  coord_flip()+
  theme_minimal()
```

El tipo de habitación más frecuente es **Entire home/apt**, seguido de **Private room**. Los usuarios de Airbnb dan mucha importancia a su privacidad, de ahí los bajos valores de las habitaciones compartidas. El resultado de las habitaciones de hotel es testimonial, ya que este tipo de alojamiento se ofertan en otras plataformas.

### ¿Cuáles son las palabras utilizadas en el título de los anuncios de alojamientos?

Se muestra el resultado con una nube de palabras.

```{r}
#Generamos el corpus a partir del campo name 
wordlist <- strsplit(df_listings$name," ")
wordlist <- as.VCorpus(wordlist)

#Normalizamos los nombres
wordlist <- tm_map(wordlist, tolower)
wordlist <- tm_map(wordlist, removePunctuation)
wordlist <- tm_map(wordlist, removeNumbers)
wordlist <- tm_map(wordlist, removeWords, stopwords(kind='en'))
wordlist <- tm_map(wordlist, removeWords, stopwords(kind='es'))
wordlist <- tm_map(wordlist, PlainTextDocument)

#Creamos el wordcloud
myDTM <- TermDocumentMatrix(wordlist, control = list(minWordLength=1))
m <- as.matrix(myDTM)
v <- sort(rowSums(m), decreasing=TRUE)
wordcloud(names(v),v, min.freq=50, colors=brewer.pal(6,"Dark2"),random.order=FALSE)
```

Las palabras más utilizadas en los títulos de los anuncios de alojamientos de Airbnb en Madrid son habitación, apartamento y centro, con sus variantes en inglés.

### ¿Qué tipo de alojamiento es el más frecuente por distrito?

```{r}
ggplot(df_listings,aes(neighbourhood_group ,fill=room_type)) + 
  geom_bar() +labs(x="Distrito", y="Tipo de alojamiento") + 
  guides(fill=guide_legend(title="")) + 
  ggtitle("Alojamientos por distrito") + 
  coord_flip()

ggplot(df_listings, aes(fill=room_type, x=neighbourhood_group, y = price))+
  geom_bar(position="fill",stat="identity") +
  labs(y= 'Alojamiento', x = 'Distrito') +
  guides(fill=guide_legend(title=""))+
  coord_flip()
```

Con la excepción de **Villaverde**, **Villa de Vallecas**, **Vicálvaro**, **San Blas - Canillejas**, **Moratalaz**,**Barajas** y **Ciudad Lineal**, en el resto de Madrid predomina el alquiler del apartamento completo en vez de habitaciones privadas o compartidas.


### ¿Existen diferencias significativas de precio para los diferentes distritos?

En los siguientes gráficos se observa la distribución de precios por distrito. Dividimos el precio en 5 grupos: **Muy bajo**, **Bajo**, **Moderado**, **Alto** y **Muy alto**.

```{r}
# Obtenemos cuantiles
quantile_price = integer(10)
for (i in 1:10) {
  quantile_price[i] = quantile(df_listings$price,i * 0.1) 
}
quantile_price
# Creamos campo nuevo con precio categorizado
df_listings <- df_listings %>% mutate(price_group=ifelse(price < quantile_price[2]+1, "Muy bajo",
                                                ifelse(price < quantile_price[4]+1, "Bajo",
                                                ifelse(price < quantile_price[6]+1, "Moderado",
                                                ifelse(price < quantile_price[8]+1, "Alto", "Muy alto"
                                                 )))))
ggplot(df_listings, aes(neighbourhood_group)) + 
  geom_bar(aes(fill = price_group)) + 
  ggtitle("Listings per price and neighbourhood group") +
  guides(fill=guide_legend(title="")) +
  coord_flip()

ggplot(df_listings, aes(x=neighbourhood_group, y=id, fill=price_group ))+
  geom_bar(position="fill", stat="identity")+
  labs(y="Price", x="Neighbourhood group")+
  guides(fill=guide_legend(title=""))+
  coord_flip()
```

En este último gráfico se aprecia la diferencia entre los precios por distritos. Mientras podemos encontrar alojamientos de cualquier tipo de precio en los distritos de la almendra central, los precios más baratos siempre están en el extrarradio.

```{r}
pal <- colorNumeric(palette=rainbow(6), domain=df_listings$price)
leaflet(data=df_listings)%>%
  addProviderTiles(providers$CartoDB.Positron)%>%
  addCircleMarkers(~longitude, ~latitude, color=~pal(price), weight=1, radius=1.5, fillOpacity=1, opacity=1,
                   label=paste("Neighbourhood:", df_listings$neighbourhood_group))%>%
  addLegend("bottomright", pal = pal, values =~price,
            title="Precio",
            opacity=1,)
```

Se comprueba si el precio sigue una distribución normal cont el test de **Kolmogorov-Smirnov**:

```{r}
is_normal_distribution <- function(x){ifelse(x >= 0.05, "Distribution normal", "NO es distribution normal")}
result <- ks.test(df_listings$price, pnorm, mean(df_listings$price), sd(df_listings$price))
is_normal_distribution(result$p.value)
```

Como la distribución no es normal, se comprueba la homocedasticidad del precio por distrito con el test de **Fligner-Killeen** (alternativa no paramétrica, utilizada cuando los datos no cumplen con la condición de normalidad): 

```{r}
is_homogeneous_variance <- function(x){ifelse(x >= 0.05, "Varianza homogénea", "Varianza NO homogénea")}

result <- fligner.test(price ~ neighbourhood_group, data = df_listings)
is_homogeneous_variance(result$p.value)
```

La variable **price** presenta varianzas estadísticamente diferentes para los diferentes distritos (**neighbourhood_group**).

La variable **price** no sigue una distribución normal y presenta varianzas estadísticamente diferentes para los diferentes distritos. Por este motivo, se usa el test de **Kruskal-Wallis**, que es la alternativa no paramétrica a los contrastes de hipótesis de más de 2 grupos para comprobar si el precio muestra diferencias significativas para los diferentes distritos. 

```{r}
kruskal.test(price ~ neighbourhood_group, data = df_listings)
```

El p-valor obtenido es menor al nivel de significancia (0.05), por tanto, se puede concluir que el precio (**price**) muestra diferencias significativas para los diferentes distritos (**neighbourhood_group**).

### ¿Cuál es el precio medio de cada tipo de alojamiento?

```{r}
mean_price_table <- aggregate(df_listings$price, list(df_listings$room_type), FUN=mean)
# Ordenamos por precio
mean_price_table[order(mean_price_table$x), ]

ggplot(df_listings, aes(x=price, fill=room_type))+
  geom_density(alpha=0.5)
```

Un alquiler de un apartamento completo tiene un precio similar al de una habitación de hotel, y es un 216% más caro que una habitación privada y un 228% más caro que una habitación compartida.


### ¿Cuantos alojamientos por tipo de habitación y precio hay? ¿Existen diferencias significativas de precio para los diferentes tipos de habitación?

```{r}
ggplot(df_listings, aes(room_type)) + geom_bar(aes(fill = price_group)) + ggtitle("Alojamientos por tipo de habitación y precio")
```

Se aprecia que los apartamentos completos tienen un rango de precios entre alto y muy alto. Las habitaciones privadas suelen ser de precio muy bajo - bajo, siendo las habitaciones compartidas generalmente de precio muy bajo.

Anteriormente, se comprobó que el precio no seguía una distribución normal. Se comprueba ahora la homocedasticidad del precio por tipo de habitación con el test de **Fligner-Killeen** (alternativa no paramétrica, utilizada cuando los datos no cumplen con la condición de normalidad): 

```{r}
result <- fligner.test(price ~ room_type, data = df_listings)
is_homogeneous_variance(result$p.value)
```

La variable **price** presenta varianzas estadísticamente diferentes para los diferentes  tipos de habitación (**room_type**).

La variable **price** no sigue una distribución normal y presenta varianzas estadísticamente diferentes para los diferentes tipos de habitación. Por este motivo, se aplica el test de **Kruskal-Wallis**, que es la alternativa no paramétrica a los contrastes de hipótesis de más de 2 grupos para comprobar si el precio muestra diferencias significativas para los diferentes tipos de habitación. 

```{r}
kruskal.test(price ~ room_type, data = df_listings)
```

El p-valor obtenido es menor al nivel de significancia (0.05), por tanto, se puede concluir que el precio (**price**) muestra diferencias significativas para los diferentes tipos de habitación (**room_type**).

### ¿Qué distritos tienen una mayor densidad de alojamientos por habitante?

Para responder a esta pregunta se necesitan los datos de población por distrito cargados en el dataframe df_population.

Se unen los datos de población a la tabla de frecuencias de anuncios por distrito calculada anteriormente.

```{r}
# Renombramos columnas de la tabla de frecuencias
colnames(neighbourhood_group_freq) <- c('neighbourhood_group', 'listings')
# Unimos datos de población
neighbourhood_group_freq <- join(neighbourhood_group_freq, df_population, type ='left')
```

Se crea una nueva variable que almacene el número de habitantes por anuncio.

```{r}
neighbourhood_group_freq$density <- round(neighbourhood_group_freq$population / neighbourhood_group_freq$listings, 0)
tail(neighbourhood_group_freq)
```

Y se visualizan los datos.

```{r}
ggplot(neighbourhood_group_freq, aes(x = reorder(neighbourhood_group, -density), y = density)) +
  geom_segment(aes(x = reorder(neighbourhood_group, - density), xend = reorder(neighbourhood_group, - density), y = 0, yend = density), color = 'gray', lwd = 1) +
  geom_point(size = 6, pch = 21, bg = 4, col = 1) +
  geom_text(aes(label=density), color = 'white', size = 2) +
  xlab('District') +
  ylab('Número de habitantes por anuncio y distrito') +
  coord_flip()+
  theme_minimal()
```

En el distrito **Centro** hay un alojamiento por cada 17 habitantes. Los 4 siguientes distritos con menor número de habitantes por alojamiento turísticos están todos en la almendra central.
En **Vicálvaro** hay un alojamiento por cada 1424 habitantes. Todos los distritos con mayor número de habitantes por alojamiento turísticos están en el extrarradio.

Se genera un mapa para visualizar los resultados geográficamente. Se aplica una normalización logarítmica para reducir el rango de valores. 

```{r}
df_listings <- merge(df_listings, neighbourhood_group_freq, type='left')
ggplot(data=df_listings) +
  geom_point(aes(x=latitude, y=longitude, color = log10(density))) +
  ggtitle('Densidad de alojamientos turísticos por habitante')
```

El mapa nos permite apreciar la mayor densidad de alojamientos turísticos en la zona central de Madrid.

### ¿Existe una diferencia significativa entre el promedio de reseñas por mes para los alojamientos de tipo habitación privada y apartamento? 

Se seleccionan los registros para los alojamientos con habitación privada y apartamento completo. 

```{r}
df_aux <- subset(df_listings, room_type=="Private room" | room_type=="Entire home/apt")
head(df_aux)
```

Se comprueba la normalidad de la distribución para las reseñas por mes (**reviews_per_month**) con el test de **Kolmogorov-Smirnov**.

```{r}
result <- ks.test(df_aux$reviews_per_month, pnorm, mean(df_aux$reviews_per_month), sd(df_aux$reviews_per_month))
is_normal_distribution(result$p.value)
```

Como la distribución no es normal, se comprueba la homocedasticidad de las reseñas mensuales por tipo de habitación con el test de **Fligner-Killeen** (alternativa no paramétrica, utilizada cuando los datos no cumplen con la condición de normalidad): 

```{r}
result <- fligner.test(reviews_per_month ~ room_type, data = df_aux)
is_homogeneous_variance(result$p.value)
```

La variable **reviews_per_month** presenta varianzas estadísticamente diferentes para los diferentes tipos de habitación (**room_type**).

No se cumplen las condiciones de normalidad, ni de homocedasticidad, por lo que se usa el test de **Kruskal-Wallis**, que es la alternativa no paramétrica a los contrastes de hipótesis con el objetivo de comprobar si las reseñas por mes muestran diferencias significativas para los tipos de habitación seleccionados. 

```{r}
kruskal.test(reviews_per_month ~ room_type, data = df_aux)
```

El p-valor obtenido es menor al nivel de significancia (0.05), por tanto, se puede concluir que las reseñas por mes (**reviews_per_month**) muestran diferencias significativas para los tipos de habitación seleccionados (**room_type**).

### ¿Existe una diferencia significativa entre los tipos de habitación por distrito?

Para comparar si existen diferencias significativas en una variable categórica entre los grupos definidos por otra variable categórica, se puede aplicar el test chi cuadrado, mediante la función **chisq.test()**.

Se construye la tabla de contingencia para ambas variables.

```{r}
# Tabla de contingencia room_type y neighbourhood_group
conting <- table(df_listings$neighbourhood_group, df_listings$room_type)
conting
```

Se aplica el test chi cuadrado.

```{r}
chisq.test(conting)
```

El p-valor obtenido es menor al nivel de significancia (0.05), por tanto, se puede concluir que el tipo de habitación (**room_type**) muestra diferencias significativas para los diferentes distritos (**neighbourhood_group**).

### ¿Cómo es la estacionalidad en el alquiler de alojamientos turísticos?

Para responder a esta pregunta hay que saber en qué momento del año se han producido los alquileres. Este dato no está disponible, pero se puede utilizar una aproximación sustituyendolo por la fecha en la que se ha hecho una reseña. Para ello se aplica el dataset **reviews_detailed.csv** que contiene un inventario de todas las reseñas realizadas.

Se convierte el campo date a tipo de datos fecha y se divide la fecha en año, mes, número de día y día de la semana.

```{r}
reviews_count <- df_reviews$date
reviews_count <- as.Date(reviews_count, "%Y-%m-%d")
reviews_count <- data.frame(date = reviews_count,
                            year = as.numeric(format(reviews_count, format = "%Y")),
                            month = as.numeric(format(reviews_count, format = "%m")),
                            day = as.numeric(format(reviews_count, format = "%d")))
reviews_count$weekday <- strftime(reviews_count$date, '%A')
head(reviews_count)
```

Se agrupa por año, mes y día de la semana para ver la evolución por cada tipo de variable.

```{r}
year <- aggregate(reviews_count$date, by = list(reviews_count$year), FUN = length)
colnames(year) <- c("Year","number_of_reviews")
month <- aggregate(reviews_count$date, by = list(reviews_count$month), FUN = length)
colnames(month) <- c("Month","number_of_reviews")
weekday <- aggregate(reviews_count$date, by = list(reviews_count$weekday), FUN = length)
colnames(weekday) <- c("Weekday", "number_of_reviews")

ggplot(reviews_count, aes(x=year)) +
  geom_bar(col ='black', fill = 'blue')+
  scale_x_discrete(limits = c(2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021)) +
  labs (title ="Reseñas por año", x = "Año", y ="Número de alojamientos")
```

Como se aprecia en el gráfico, el negocio de los alojamientos turísticos crecía de forma exponencial desde el año 2015. La brusca caída se debe a los efectos del COVID-19 en el año 2020, situación que continua en 2021. 

Nota: los últimos datos del dataset son de Abril de 2021, por lo que no se puede apreciar en el gráfico si hay recuperación con respecto a 2020 o no.

```{r}
ggplot(reviews_count, aes(x=month)) +
  geom_bar(col ='black', fill = 'blue')+
  scale_x_discrete(limits = c("Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre")) +
  labs (title ="Reseñas por mes", x = "Mes", y ="Número de alojamientos")+
  coord_flip()

```

Sorprende que las reseñas se mantienen más o menos constantes a lo largo del año. Aún más que sean los meses de verano donde menos reseñas se escriben. 

```{r}
ggplot(data=reviews_count, aes(x=weekday)) + 
  geom_bar(col='black', fill ='blue') +
  labs (title = "Reseñas por días", x = "Días", y="Número de alojamientos")
```

Mientras que las reseñas permanecen constante a lo largo de los días de la semana, se ve un fuerte incremento en los domingos y lunes, lo que nos indica que los fines de semana es cuando más se reservan los alojamientos turísticos.

### ¿Se podría construir un modelo de regresión para predecir el precio del alojamiento en función de otras variables?

Se busca predecir el precio de alquiler de un alojamiento turístico (variable dependiente cuantitativa) en función de una serie de variables cualitativas y cuantitativas (variables independientes). Para ello se utiliza un modelo de regresión lineal múltiple.

Se ha comprobado antes que la variable price no sigue una distribución normal, afectada sobre todo, por valores extremos debido al lujo. Se utiliza una transformación logarítmica para acercar más su distribución a la normalidad.

```{r}
df_listings$price_trans <- log2(df_listings$price)
qqnorm(df_listings$price_trans); qqline(df_listings$price_trans)
```

Tras hacer la transformación, se observa que la nueva variable price_trans se acerca más a una distribución normal.

El modelo de regresión lineal emplea la relación lineal entre dos variables para predecir el valor que va a tomar una en función del valor que toma la otra. La condición para que funcione es que ambas variables estén correlacionadas. El primer paso a la hora de plantear un modelo de regresión lineal es hacer un estudio de correlación. 

```{r}
df_reg <- df_listings[,c("price_trans", "minimum_nights", "reviews_per_month", "availability_365", "latitude", "longitude")]

correlacionMatrix <- cor(df_reg)
corrplot(corr = cor(correlacionMatrix, method = "pearson"), method = "number", tl.cex = 0.7,number.cex = 0.8, cl.pos = "n")

# Generamos un dataset con las variables que van a formar parte del estudio
df_reg <-df_listings[,c("price_trans", "minimum_nights", "reviews_per_month", "availability_365", "latitude", "longitude","neighbourhood_group","room_type")]
```

Se observa que la correlación entre el precio y el resto de las variables es bajo.

La correlación más alta se da entre **price_trans** y **longitude**, pero es muy baja (-0.34). 

Se convierten en factores los distintos valores de las variables categóricas, y se usan los valores con mayor peso como valores de referencia. En este caso sería el distrito Centro y el tipo de habitación Entire home/apartment.

```{r}
df_reg$neighbourhood_group <- as.factor(df_reg$neighbourhood_group)
df_reg$room_type <- as.factor(df_reg$room_type)
df_reg$neighbourhood_group <- relevel(df_reg$neighbourhood_group, ref="Centro")
df_reg$room_type <- relevel (df_reg$room_type, ref="Entire home/apt")
```

Se crean distintos modelos usando distintas combinaciones de las variables cualitativas y cuantitativas

```{r}
model1 <- lm(price_trans ~., data=df_reg)
model2 <- lm(price_trans ~ reviews_per_month + room_type + neighbourhood_group, data=df_reg)
model3 <- lm(price_trans ~ reviews_per_month + longitude + latitude + room_type + neighbourhood_group, data=df_reg)
model4 <- lm(price_trans ~ reviews_per_month + longitude + latitude + minimum_nights + room_type + neighbourhood_group, data=df_reg)
model5 <- lm(price_trans ~ minimum_nights + room_type + neighbourhood_group, data=df_reg)
model6 <- lm(price_trans ~ availability_365 + room_type + neighbourhood_group, data=df_reg)
model7 <- lm(price_trans ~ reviews_per_month + room_type + neighbourhood_group +longitude:latitude, data=df_reg)
model8 <- lm(price_trans ~ room_type + neighbourhood_group + reviews_per_month:availability_365, data=df_reg)
model9 <- lm(price_trans ~ room_type + neighbourhood_group, data=df_reg)
```

La bondad del ajuste se mide con el parámetro Adjusted R-squared, cuándo este valor es próximo a 1 es indicativo de un buen modelo de ajuste. Se utiliza este parámetro para elegir el modelo con el mejor coeficiente.

```{r}
#Generamos los coeficientes de determinación de cada modelo
tabla.coef <- matrix(c(1, summary(model1)$r.squared,
                       2, summary(model2)$r.squared,
                       3, summary(model3)$r.squared,
                       4, summary(model4)$r.squared,
                       5, summary(model5)$r.squared,
                       6, summary(model6)$r.squared,
                       7, summary(model7)$r.squared,
                       8, summary(model8)$r.squared,
                       9, summary(model9)$r.squared),
                     ncol=2,byrow=TRUE)
colnames(tabla.coef) <-c("Modelo","R-squared")
tabla.coef
```

Se elige como mejor modelo a áquel que tiene el coeficiente de determinación mayor. En este caso el modelo 1.

Por último, para profundizar en la calidad del ajuste deben analizarse los residuos que nos indicarán realmente cómo se ajusta nuestro modelo a los datos muestrales.

Para obtener los residuos se aplica la función [rstandard](https://www.rdocumentation.org/packages/TSA/versions/1.3/topics/rstandard.Arima) sobre el modelo. Esta función devuelve los residuos. A continuación se estudian sus estadísticos

```{r}
residuos <- model1$residuals
summary(residuos)
boxplot(residuos)
qqnorm(residuos)
qqline(residuos)
```

Los residuos siguen una distribución aparentemente normal, la distribución de los datos es simétrica respecto a su mediana, y el tamaño de la caja desde el primer al tercer cuartil es también simétrica respecto a la mediana, que está a su vez, centrada en el 0.

Se genera también la gráfica de residuos vs valores ajustados. Esta gráfica muestra los residuos en el eje Y y los valores ajustados en el eje X. Se utiliza para verificar el supuesto de que los residuos están distribuidos aleatoriamente y tienen una varianza constante. Lo ideal es que los puntos se ubiquen aleatoriamente a ambos lados del eje X.

Si existe una dispersión en abanico es síntoma de que la varianza no es constante. Esto también se aprecia en la línea azul que fluctúa a lo largo del eje X.

```{r}
# Comparamos los valores ajustados con los residuos
ggplot(data=df_reg, aes(model1$fitted.values, model1$residuals)) + 
  geom_point() + 
  geom_smooth(color ="blue", se = FALSE)+
  geom_hline(yintercept = 0) + 
  ggtitle('Valores ajustados vs Residuos')+
  theme_bw()
```
Respecto a la bondad del modelo, se observan estos parámetros:

```{r}
summary(model1)
```

Residual standard error: 0.7378 on 18248 degrees of freedom.

Multiple R-squared:  0.4512,	Adjusted R-squared:  0.4504

F-statistic:  535.8 on 28 and 18248 DF,  p-value: < 2.2e-16.

El RSE es la desviación estandar de los residuos, cuánto menor mejor. 

El modelo es capaz de explicar el 45% de la variabilidad observada en los precios

El test F muestra un p-value menor de 0.05 por lo que el modelo en conjunto es significativo.

## Modelo de regresión logística

Se prueba ahora un modelo que sea capaz de calcular la probabilidad de que el precio de alquiler de un alojamiento turístico supere los 100 euros por noche.
Para ello discretizamos la variable precio en dos categorías: <= 100 euros y >100 euros

```{r}
#Creamos la variable dependiente cualitativa dicotómica price_100
df_listings$price_100 <- factor(ifelse(df_listings$price>100,"Yes","No"))

#Preparamos los datos para la regresión
df_reg <-df_listings[,c("price_100", "minimum_nights", "reviews_per_month", "availability_365", "latitude", "longitude","neighbourhood_group","room_type")]
df_reg$neighbourhood_group <- as.factor(df_reg$neighbourhood_group)
df_reg$room_type <- as.factor(df_reg$room_type)
df_reg$neighbourhood_group <- relevel(df_reg$neighbourhood_group, ref="Centro")
df_reg$room_type <- relevel (df_reg$room_type, ref="Entire home/apt")
```

Creamos distintos modelos usando distintas combinaciones de las variables cualitativas y cuantitativas

```{r}
#Generamos distintos modelos
logi1 <- glm(formula = price_100 ~ ., data=df_reg, family= binomial(link=logit))
logi2 <- glm(formula = price_100 ~ reviews_per_month + room_type + neighbourhood_group, data=df_reg, family= binomial(link=logit))
logi3 <- glm(formula = price_100 ~ reviews_per_month + longitude + latitude + room_type + neighbourhood_group, data=df_reg, family= binomial(link=logit))
logi4 <- glm(formula = price_100 ~ reviews_per_month + longitude + latitude + minimum_nights + room_type + neighbourhood_group, data=df_reg, family= binomial(link=logit))
logi5 <- glm(formula = price_100 ~ minimum_nights + room_type + neighbourhood_group, data=df_reg, family= binomial(link=logit))
logi6 <- glm(formula = price_100 ~ availability_365 + room_type + neighbourhood_group, data=df_reg, family= binomial(link=logit))
logi7 <- glm(formula = price_100 ~ reviews_per_month + room_type + neighbourhood_group +longitude:latitude, data=df_reg, family= binomial(link=logit))
logi8 <- glm(formula = price_100 ~ room_type + neighbourhood_group + reviews_per_month:availability_365, data=df_reg, family= binomial(link=logit))
logi9 <- glm(formula = price_100 ~ room_type + neighbourhood_group, data=df_reg, family= binomial(link=logit))
```

La bondad del ajuste se va a medir con el criterio de información de Akaike. El menor de los valores nos indicará cual es el mejor modelo. En este caso el modelo 1.

```{r}
#Generamos los AIC (criterio de información de Akaike) para comparar los modelos
tabla.coef <- matrix(c(1, summary(logi1)$aic,
                       2, summary(logi2)$aic,
                       3, summary(logi3)$aic,
                       4, summary(logi4)$aic,
                       5, summary(logi5)$aic,
                       6, summary(logi6)$aic,
                       7, summary(logi7)$aic,
                       8, summary(logi8)$aic,
                       9, summary(logi9)$aic),
                     ncol=2,byrow=TRUE)
colnames(tabla.coef) <-c("Modelo","R-squared")
tabla.coef
```
Se analiza la precisión del modelo, comparando la predicción del modelo contra un conjunto de prueba (train-test).

```{r}
#Generamos los datos de entrenamiento y test
set.seed(100)
n<-nrow(df_reg)
train_index <- sample(1:n, size=round(0.8*n), replace=FALSE)
train <- df_reg[train_index,]
test <- df_reg[-train_index,]

#Generamos el modelo
logist1 <- glm(formula = price_100 ~ ., data=train, family= binomial(link=logit))
summary(logist1)
```

Se aplica el modelo a los datos de test que habíamos generado

```{r}
#Generamos las predicciones
predicted <- predict(logist1, test, type="response")
predicted <-ifelse(predicted<0.5,"No","Yes")
#Generamos la matriz de confusion
confusionMatrix(test$price_100, as.factor(predicted))
```

La matriz de confusión nos da una exactitud del 82.2%, esto es, la habilidad del modelo para detectar correctamente los alquileres por encima y debajo de 100 euros.

La sensibilidad es del 82.5%, es la habilidad de detectar verdaderos positivos en el total de positivos que hay en la realidad. Consideramos como positivo el que el alquiler sea mayor de 100 euros la noche.

La especificidad es del 58.5%, es la habilidad del modelo de detectar verdaderos negativos en el total de negativos reales. El modelo es solo capaz de predecir el 58.5% de los casos reales donde el precio es mayor de 100 euros.

******
# Conclusiones
******

Atendiendo a las respuestas obtenidas en todas y cada una de las preguntas que se han realizado se llegan a las siguientes conclusiones:

**- ¿Qué tipo de vivienda comprar?**

Viviendas de segunda mano, de tamaño mediano-pequeño, a reformar.

El hecho de comprar viviendas de segundo mano se explica por la ausencia de promociones de obra nueva en las zonas de interés. Se explica en el siguiente punto cuáles son estas zonas.

Viviendas de tamaño mediano-pequeño, ya que la vivienda preferida por los usuarios de Airbnb son los apartamentos enteros. El precio se incrementa hasta un 250% con respecto a alquilar una habitación compartida. Para compensar esto, se requerirían varias habitaciones privadas en el mismo inmueble, pero implicaría inmuebles más caros de comprar y de reformar.

En el análisis de palabras más utilizadas en los anuncios se observan muchos términos relacionados con la localización y tipo de inmueble, pero también hay adjetivos como: stylish, acogedor, precioso, beautiful, cozy, luxury, lovely, luminosa, spacious, lo que indica una necesidad de transformar los inmuebles de acuerdo a las tendencias de decoración minimalista actuales.

**- ¿En qué zona de la capital?**

Viviendas en la zona de la almendra central pero fuera del **Centro** debido a la saturación del mismo (17 habitantes por alojamiento turístico).

Se recomiendan oportunidades en barrios más caros como **Chamberí**, **Salamanca**, y **Retiro**, y centrar los esfuerzos en adquirir imuebles en zonas de la almendra central con menor coste: 
**Arganzuela**, **Tetuán**, **Chamartín**. Otra opción muy interesante por precio y su proximidad al aeropuerto sería **Barajas**.

Las oportunidades serían ventas de inmuebles ya destinados al alquiler turístico en el que la inversión por reforma no sería necesaria. Sería posible encontrar estas oportunidades debido a los efectos de la pandemia.

**- ¿Qué destino se le va a dar al inmueble?**

La inversión debe destinarse al alquiler turístico. Es un mercado que hasta la pandemia de COVID-19 crecía de forma exponencial y al que se ven signos de recuperación. 

Según las [estadísticas del Ayuntamiento de Madrid](http://www-2.munimadrid.es/CSE6/control/seleccionDatos?numSerie=05040201030) la superficie media de la vivienda en Madrid es de 82 m2. 

Según el portal [idealista](https://www.idealista.com/sala-de-prensa/informes-precio-vivienda/alquiler/madrid-comunidad/madrid-provincia/madrid/) el precio medio del alquiler en Madrid en Noviembre de 2021 es de 14,6 euros/metro cuadrado. Por lo tanto, el precio medio del aquiler tradicional es de 1197 euros al mes.

En este ejercicio se ha comprobado que el precio medio del alquiler turístico es de 88 euros/noche, por lo que llegaría a los 2640 euros al mes (considerando 30 días). Un 220% más.

El análisis de estacionalidad del alquiler turístico también nos muestra homogeneidad a lo largo de los meses y una alta ocupación durante todos los días de la semana.


******
# Contribución
******

|Contribuciones   |Firma|
|:------|:--------------|
|Investigación previa| BLB, GRF|
|Redacción de las respuestas| BLB, GRF|
|Desarrollo del código| BLB, GRF|

